<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

    <meta charset="UTF-8">
    <base href="/">
    <link rel="stylesheet" href="static/styles.css">
    <link rel="stylesheet" href="static/github-markdown.css">
    <link rel="stylesheet" href="static/starry_night.css">
    <title>RustLinuxKernelModule</title>


<div id="menu">
<a href=/ class="menu-item">Home</a><a href=/table-of-contents.html class="menu-item">Table of contents</a>
</div>
<div id="content">
<div class="markdown-body"><h1>Rust for Linux, how hard is it to write a Kernel module in Rust?</h1>
<p>Once again I'm back on parental leave, I've been lazily following the <a href="https://rust-for-linux.com/">Rust for Linux</a>
effort but finally decided to get into it and write a simple kernel module in <code>Rust</code>.</p>
<hr>
<h2>Introduction</h2>
<p>This write-up is about writing a kernel module in <code>Rust</code> which will expose a file under <code>/proc/rust-proc-file</code>,
the file is going to function as a regular file, but backed by just ram.</p>
<p>It'll go through zero-cost abstractions and how one can safely wrap <code>unsafe extern "C" fn</code>s hiding away
the gritty details of <code>C</code>-APIs.</p>
<p>It'll also go through numerous ways of causing and avoiding <a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html">undefined behaviour (UB)</a>
, as well as some kernel internals.</p>
<p>This write-up is code-heavy, all code shown is licensed under GPLv2 and generally there are links
with the code which can be followed to the source which also contains its license.</p>
<hr>
<h2>Table of contents</h2>
<ul>
<li><a href="#rust-for-linux-how-hard-is-it-to-write-a-kernel-module-in-rust">Rust for Linux, how hard is it to write a Kernel module in Rust?</a>
<ul>
<li><a href="#introduction">Introduction</a>
<li><a href="#table-of-contents">Table of contents</a>
<li><a href="#objective">Objective</a>
<li><a href="#the-proc-filesystem">The proc Filesystem</a>
<ul>
<li><a href="#a-proc-file">A proc 'file'</a>
<li><a href="#the-proc-api">The proc API</a>
<li><a href="#proc_open">proc_open</a>
<li><a href="#proc_read">proc_read</a>
<li><a href="#proc_write">proc_write</a>
<li><a href="#proc_lseek">proc_lseek</a>
</ul>

<li><a href="#implementing-it-in-rust">Implementing it in Rust</a>
<ul>
<li><a href="#generating-bindings">Generating bindings</a>
<li><a href="#unsafe-extern-c-fn">unsafe extern "C" fn</a>
<li><a href="#abstraction">Abstraction</a>
<li><a href="#better-function-signatures">Better function signatures</a>
<li><a href="#a-safe-reference-to-the-file-struct">A safe reference to the <code>file</code>-struct</a>
<ul>
<li><a href="#data-races">Data-races</a>
<li><a href="#an-acceptable-data-race">An acceptable data race</a>
<li><a href="#handling-reading-racy-data-for-more-complex-structs">Handling reading racy data for more complex structs</a>
</ul>

<li><a href="#back-to-abstracting">Back to abstracting</a>
<li><a href="#wrapping-the-unsafe-extern-c-fn">Wrapping the <code>unsafe extern "C" fn</code></a>
<li><a href="#using-the-abstraction">Using the abstraction</a>
<ul>
<li><a href="#user-pointers">User pointers</a>
</ul>

<li><a href="#writing-the-module">Writing the module</a>
<li><a href="#mutex">Mutex</a>
<li><a href="#storing-the-procdirentry">Storing the ProcDirEntry</a>
<li><a href="#memory-lifecycle-you-me-and-c">Memory lifecycle, you, me, and <code>C</code></a>
<ul>
<li><a href="#a-user-interaction">A user interaction</a>
<li><a href="#constraints-caused-by-static-lifetimes">Constraints caused by <code>'static</code>-lifetimes</a>
<li><a href="#using-static-data-for-the-backing-storage">Using static data for the backing storage</a>
<li><a href="#maybeuninitt-vs-unsafecelloptiont">MaybeUninit vs UnsafeCell&#x3C;Option></a>
<li><a href="#global-pops-and-an-unsound-api">Global POPS and an unsound API</a>
<li><a href="#deallocation">Deallocation</a>
</ul>

</ul>

<li><a href="#testing">Testing</a>
<ul>
<li><a href="#objective-retrospective">Objective retrospective</a>
<li><a href="#implementing-tests">Implementing tests</a>
</ul>

<li><a href="#summing-up">Summing up</a>
<ul>
<li><a href="#generating-bindings-1">Generating bindings</a>
<li><a href="#wrapping-the-api-with-reasonable-lifetimes">Wrapping the API with reasonable lifetimes</a>
<li><a href="#dealing-with-static-data-in-a-concurrent-context">Dealing with static data in a concurrent context</a>
<li><a href="#tradeoff-between-soundness-and-performance">Tradeoff between soundness and performance</a>
<li><a href="#testing-">Testing</a>
<li><a href="#shortcomings">Shortcomings</a>
</ul>

</ul>

</ul>
<hr>
<h2>Objective</h2>
<p>I've been a Linux user for quite a while but have never tried my hand at contributing to the codebase,
the reason is that I generally spend my free time writing things that I myself would use. Having
that as a guide leads to me finishing my side-projects. There hasn't been something that I've wanted or needed
that I've been unable to implement in user-space, so it just hasn't happened.</p>
<p>Sadly, that's still the case, so I had to contrive something: A proc-file that works just like a regular file.</p>
<hr>
<h2>The proc Filesystem</h2>
<p>The stated purpose of the <code>/proc</code> filesystem is to</p>
<blockquote>
<p>provide information about the running Linux System</p>
</blockquote>
<p>read more about it <a href="https://www.kernel.org/doc/html/latest/filesystems/proc.html">here</a>.</p>
<p>On a Linux machine with the <code>/proc</code> filesystem you can find process information e.g. under <code>/proc/&#x3C;pid>/..</code>,
like memory usage, mounts, cpu-usage, fds, etc. With the above stated purpose and how the <code>/proc</code> filesystem is
used, the purpose of this module doesn't quite fit it, but for simplicity I chose <code>proc</code> anyway.</p>
<hr>
<h3>A proc 'file'</h3>
<p>Proc files can be created by the kernel's <code>proc_fs</code>-api, it lives <a href="https://github.com/Rust-for-Linux/linux/blob/e31f0a57ae1ab2f6e17adb8e602bc120ad722232/include/linux/proc_fs.h">here</a>.
Proc files are not like the most commonly imagined regular file, some data that exists on a disk somewhere,
it's an interface into the kernel.</p>
<p>On the kernel side, to create the 'file' <a href="https://github.com/Rust-for-Linux/linux/blob/e31f0a57ae1ab2f6e17adb8e602bc120ad722232/include/linux/proc_fs.h#L111">proc_create</a>,
can be used, it looks like this:</p>
<div class="highlight highlight-c"><pre><span class="pl-k">struct</span> proc_dir_entry *<span class="pl-en">proc_create</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *name, <span class="pl-c1">umode_t</span> mode, <span class="pl-k">struct</span> proc_dir_entry *parent, <span class="pl-k">const</span> <span class="pl-k">struct</span> proc_ops *proc_ops);
</pre></div>
<p>When invoked with correct arguments it will create a file under <code>/proc/&#x3C;name></code> (if no parent is provided).</p>
<p>That <code>file</code> is an interface to the kernel, a user interacts with it as a regular file on one end,
and the kernel provides handlers for regular file-functionality on the other end (like <code>open</code>, <code>read</code>, <code>write</code>, <code>lseek</code>,
etc.).</p>
<p>That interface is provided through the last argument <code>...,proc_ops *proc_ops);...</code></p>
<hr>
<h3>The proc API</h3>
<p>On the <code>C</code>-side, the proc API as exposed through the <code>proc_ops</code>-struct:</p>
<p><a href="https://github.com/Rust-for-Linux/linux/blob/e31f0a57ae1ab2f6e17adb8e602bc120ad722232/include/linux/proc_fs.h#L29">proc_ops</a>:</p>
<div class="highlight highlight-c"><pre><span class="pl-k">struct</span> proc_ops {
	<span class="pl-k">unsigned</span> <span class="pl-k">int</span> proc_flags;
	<span class="pl-c1">int</span>	(*proc_open)(<span class="pl-k">struct</span> inode *, <span class="pl-k">struct</span> file *);
	<span class="pl-c1">ssize_t</span>	(*proc_read)(<span class="pl-k">struct</span> file *, <span class="pl-k">char</span> __user *, <span class="pl-c1">size_t</span>, <span class="pl-c1">loff_t</span> *);
	<span class="pl-c1">ssize_t</span> (*proc_read_iter)(<span class="pl-k">struct</span> kiocb *, <span class="pl-k">struct</span> iov_iter *);
	<span class="pl-c1">ssize_t</span>	(*proc_write)(<span class="pl-k">struct</span> file *, <span class="pl-k">const</span> <span class="pl-k">char</span> __user *, <span class="pl-c1">size_t</span>, <span class="pl-c1">loff_t</span> *);
	<span class="pl-c">/* mandatory unless nonseekable_open() or equivalent is used */</span>
	<span class="pl-c1">loff_t</span>	(*proc_lseek)(<span class="pl-k">struct</span> file *, <span class="pl-c1">loff_t</span>, <span class="pl-k">int</span>);
	<span class="pl-c1">int</span>	(*proc_release)(<span class="pl-k">struct</span> inode *, <span class="pl-k">struct</span> file *);
	<span class="pl-c1">__poll_t</span> (*proc_poll)(<span class="pl-k">struct</span> file *, <span class="pl-k">struct</span> poll_table_struct *);
	<span class="pl-c1">long</span>	(*proc_ioctl)(<span class="pl-k">struct</span> file *, <span class="pl-k">unsigned</span> <span class="pl-k">int</span>, <span class="pl-k">unsigned</span> <span class="pl-k">long</span>);
#<span class="pl-k">ifdef</span> CONFIG_COMPAT
	<span class="pl-c1">long</span>	(*proc_compat_ioctl)(<span class="pl-k">struct</span> file *, <span class="pl-k">unsigned</span> <span class="pl-k">int</span>, <span class="pl-k">unsigned</span> <span class="pl-k">long</span>);
#<span class="pl-k">endif</span>
	<span class="pl-c1">int</span>	(*proc_mmap)(<span class="pl-k">struct</span> file *, <span class="pl-k">struct</span> vm_area_struct *);
	<span class="pl-k">unsigned</span> <span class="pl-smi">long</span> (*proc_get_unmapped_area)(<span class="pl-k">struct</span> file *, <span class="pl-k">unsigned</span> <span class="pl-k">long</span>, <span class="pl-k">unsigned</span> <span class="pl-k">long</span>, <span class="pl-k">unsigned</span> <span class="pl-k">long</span>, <span class="pl-k">unsigned</span> <span class="pl-k">long</span>);
} __randomize_layout;
</pre></div>
<p>It accepts flags and function pointers, the function pointers can in many cases be <code>null</code> without unsafety,
but will impact functionality for the 'file'. For example, if <code>write</code>-isn't implement the file won't be writable,
that's not a problem if the purpose of the 'file' is to just expose readable information.</p>
<p>The functions that will be implemented follows.</p>
<hr>
<h3>proc_open</h3>
<p>When a user tries to <code>open</code> the proc-file, the handler <code>int	(*proc_open)(struct inode *, struct file *);</code>
will be invoked.</p>
<p>A perfectly functional <code>C</code>-implementation of that, in the case that no work needs to be done specifically when a
user invokes <code>open</code> is:</p>
<div class="highlight highlight-c"><pre><span class="pl-k">int</span> <span class="pl-en">proc_open</span>(<span class="pl-k">struct</span> inode *inode, <span class="pl-k">struct</span> file *file)
{
	<span class="pl-k">return</span> <span class="pl-c1">0</span>;
}
</pre></div>
<p>It just returns <code>0</code> for success.</p>
<hr>
<h2>There are cases where one would like to do something when the file is opened, in that case,
the <code>*file</code>-pointer could be modified, for example by writing to the <code>void *private_data</code>-field to add some data
that will follow the file through its coming operations.
Read more about the <a href="https://www.oreilly.com/library/view/linux-device-drivers/0596000081/ch03s04.html">file structure here</a>,
or check out its definition <a href="https://github.com/Rust-for-Linux/linux/blob/e31f0a57ae1ab2f6e17adb8e602bc120ad722232/include/linux/fs.h#L992">here</a>.</h2>
<h3>proc_read</h3>
<p>Now onto some logic, when a user wants to read from the file
the user provides a buffer and an offset pointer, the signature looks like
<a href="https://github.com/Rust-for-Linux/linux/blob/e31f0a57ae1ab2f6e17adb8e602bc120ad722232/include/linux/proc_fs.h#L32">this:</a></p>
<div class="highlight highlight-c"><pre><span class="pl-c1">ssize_t</span>	<span class="pl-en">proc_read</span>(<span class="pl-k">struct</span> file *f, <span class="pl-k">char</span> __user *buf, <span class="pl-c1">size_t</span> buf_len, <span class="pl-c1">loff_t</span> *offset);
</pre></div>
<p>Again there's the <code>file</code>-structure pointer which could contain e.g. <code>private_data</code> that
was put there in an <code>open</code>-implementation, as well as a suspiciously annotated
<code>char __user *buf</code>.</p>
<p>The kernel should write data into the user buffer, return the number of
bytes written, and update the offset through the pointer.</p>
<hr>
<h3>proc_write</h3>
<p>When a user tries to write to the file, it enters through
<a href="https://github.com/Rust-for-Linux/linux/blob/e31f0a57ae1ab2f6e17adb8e602bc120ad722232/include/linux/proc_fs.h#L34">proc_write</a>,
which looks like this:</p>
<div class="highlight highlight-c"><pre><span class="pl-c1">ssize_t</span>	(*proc_write)(<span class="pl-k">struct</span> file *f, <span class="pl-k">const</span> <span class="pl-k">char</span> __user *buf, <span class="pl-c1">size_t</span> buf_len, <span class="pl-c1">loff_t</span> *offset);
</pre></div>
<p>The user provides the buffer it wants to write into the file along with its length, and
a pointer to update the offset. Again suspiciously annotating the buffer with <code>__user</code>.</p>
<p>The kernel should write data from the user buffer into the backing storage.</p>
<hr>
<h3>proc_lseek</h3>
<p>Lastly, if the file is to be seekable to an offset <a href="https://github.com/Rust-for-Linux/linux/blob/e31f0a57ae1ab2f6e17adb8e602bc120ad722232/include/linux/proc_fs.h#L36">proc_lseek</a>
has to be implemented.</p>
<p>It's signature looks like this:</p>
<div class="highlight highlight-c"><pre><span class="pl-c1">loff_t</span> (*proc_lseek)(<span class="pl-k">struct</span> file *f, <span class="pl-c1">loff_t</span> offset, <span class="pl-k">int</span> whence);
</pre></div>
<p>Again the file is provided, the offset to seek to, and <code>whence</code> to seek,
<code>whence</code> is an <code>int</code> which should have one of 5 values, those are described
more in the docs <a href="https://man7.org/linux/man-pages/man2/lseek.2.html">here</a>,
the most intuitive one is <code>SEEK_SET</code> which means that the file's offset should
be set to the offset that the user provided.</p>
<p>Assuming that the offset makes sense, the module should return the new offset.</p>
<hr>
<h2>Implementing it in Rust</h2>
<p>That's it, with those 4 functions implemented there should be a fairly complete working
file created when the functions are passed as members of the <code>proc_ops</code>-struct, time to start!</p>
<h3>Generating bindings</h3>
<p>Rust for Linux uses Rust-bindings generated from the kernel headers.
They're conveniently added when building, as long as the correct headers are
added <a href="https://github.com/MarcusGrass/linux/blob/8e8c948133ca1a0cbf8f8add191daa739a193d99/rust/bindings/bindings_helper.h#L19">here</a>,
for this module only <code>proc_fs.h</code> is needed.</p>
<h3>unsafe extern "C" fn</h3>
<p>Since <code>Rust</code> is compatible with <code>C</code> by jumping through some hoops,
theoretically the module could be implemented by just using the C-api
directly as-is through the functions provided by the bindings.</p>
<p>One of <code>Rust</code>'s strengths is being able to take unsafe code and make safe abstractions
on top of them. However, using those functions directly can be a good start to figure out
how the APIs work.</p>
<p>The generated <code>Rust</code> functions-pointer-definitions look like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">proc_open</span>(
        <span class="pl-smi">inode</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">inode</span>,
        <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
    ) <span class="pl-k">-></span> <span class="pl-en">i32</span> {
    <span class="pl-k">...</span>
}
<span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">proc_read</span>(
    <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
    <span class="pl-smi">buf</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_char</span>,
    <span class="pl-smi">buf_cap</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
    <span class="pl-smi">read_offset</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
) <span class="pl-k">-></span> <span class="pl-en">isize</span> {
    <span class="pl-k">...</span>
}
<span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">proc_write</span>(
    <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
    <span class="pl-smi">buf</span><span class="pl-k">:</span> <span class="pl-k">*const</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_char</span>,
    <span class="pl-smi">buf_cap</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
    <span class="pl-smi">write_offset</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
) <span class="pl-k">-></span> <span class="pl-en">isize</span> {
    <span class="pl-k">...</span>
}
<span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">proc_lseek</span>(
    <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
    <span class="pl-smi">offset</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
    <span class="pl-smi">whence</span><span class="pl-k">:</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_int</span>,
) <span class="pl-k">-></span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span> {
    <span class="pl-k">...</span>
}
</pre></div>
<p>One difference between these <code>C</code>-style function declarations and something
like <code>Rust</code>'s <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code>-traits</a>
is that these function cannot capture any state.</p>
<p>This necessitates using global-statics for persistent state that has to
be shared between user-calls into the proc-file (like writing to the backing file data).
For modifications that do not have to be shared or persisted after the interaction ends
, the <code>file</code>'s private data could be used.</p>
<p>Another difference is that that pesky <code>__user</code>-annotation is finally gone, let's not
think more about that, the problem solved itself.</p>
<hr>
<h3>Abstraction</h3>
<p>As mentioned previously, a strength of <code>Rust</code>'s is being able to
abstract away <code>unsafety</code>, ideally an API would consist of <code>Rust</code> function-signatures
containing references instead of <code>C</code>-style function-signatures containing raw pointers,
it's a bit tricky, but it can be done without overhead.</p>
<p>Here's an example of how to do the conversion in a way with zero-cost:</p>
<p>Without any conversion, calling a rust-function within a <code>C</code>-style function:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">rust_fn</span>() <span class="pl-k">-></span> <span class="pl-en">i32</span> {
    <span class="pl-en">std</span><span class="pl-k">::</span><span class="pl-en">hint</span><span class="pl-k">::</span><span class="pl-en">black_box</span>(<span class="pl-c1">5</span>) <span class="pl-k">*</span> <span class="pl-en">std</span><span class="pl-k">::</span><span class="pl-en">hint</span><span class="pl-k">::</span><span class="pl-en">black_box</span>(<span class="pl-c1">15</span>)
}
<span class="pl-k">pub</span> <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">my_callback2</span>() <span class="pl-k">-></span> <span class="pl-en">i32</span> {
    <span class="pl-en">rust_fn</span>()
}
<span class="pl-k">pub</span> <span class="pl-k">fn</span> <span class="pl-en">main</span>() <span class="pl-k">-></span> <span class="pl-en">i32</span>{
    <span class="pl-k">unsafe</span> {
        <span class="pl-en">my_callback2</span>()
    }
}
</pre></div>
<p>This allows the user to define <code>rust_fn</code>, and then wrap it with <code>C</code>-style function.</p>
<p>Through <a href="https://godbolt.org">godbolt</a> it produces this assembly:</p>
<pre><code class="language-nasm">example::my_callback2::h381eee3be316e700:
        mov     dword ptr [rsp - 8], 5
        lea     rax, [rsp - 8]
        mov     eax, dword ptr [rsp - 8]
        mov     dword ptr [rsp - 4], 15
        lea     rcx, [rsp - 4]
        imul    eax, dword ptr [rsp - 4]
        ret
example::main::h11eebe12cad5e117:
        mov     dword ptr [rsp - 8], 5
        lea     rax, [rsp - 8]
        mov     eax, dword ptr [rsp - 8]
        mov     dword ptr [rsp - 4], 15
        lea     rcx, [rsp - 4]
        imul    eax, dword ptr [rsp - 4]
        ret
</code></pre>
<p>The above shows that the entire function my_callback2 was inlined
into main, a zero-cost abstraction should produce the same code,
so any abstraction should produce the same assembly.</p>
<p>Here is an example of such an abstraction:</p>
<div class="highlight highlight-rust"><pre>
<span class="pl-k">fn</span> <span class="pl-en">rust_fn</span>() <span class="pl-k">-></span> <span class="pl-en">i32</span> {
    <span class="pl-en">std</span><span class="pl-k">::</span><span class="pl-en">hint</span><span class="pl-k">::</span><span class="pl-en">black_box</span>(<span class="pl-c1">5</span>) <span class="pl-k">*</span> <span class="pl-en">std</span><span class="pl-k">::</span><span class="pl-en">hint</span><span class="pl-k">::</span><span class="pl-en">black_box</span>(<span class="pl-c1">15</span>)
}
<span class="pl-k">pub</span> <span class="pl-k">trait</span> <span class="pl-en">MyTrait</span>&#x3C;'<span class="pl-en">a</span>> {
    <span class="pl-k">const</span> <span class="pl-c1">CALLBACK_1</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span>'<span class="pl-en">a</span> <span class="pl-k">dyn</span> <span class="pl-en">Fn</span>() <span class="pl-k">-></span> <span class="pl-en">i32</span>;
}
<span class="pl-k">pub</span> <span class="pl-k">struct</span> <span class="pl-en">MyStruct</span>;
<span class="pl-k">impl</span>&#x3C;'<span class="pl-en">a</span>> <span class="pl-en">MyTrait</span>&#x3C;'<span class="pl-en">a</span>> <span class="pl-k">for</span> <span class="pl-en">MyStruct</span> {
    <span class="pl-k">const</span> <span class="pl-c1">CALLBACK_1</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span>'<span class="pl-en">a</span> <span class="pl-k">dyn</span> <span class="pl-en">Fn</span>() <span class="pl-k">-></span> <span class="pl-en">i32</span> <span class="pl-k">=</span> <span class="pl-k">&#x26;</span><span class="pl-smi">rust_fn</span>;
}
<span class="pl-k">pub</span> <span class="pl-k">struct</span> <span class="pl-en">Container</span>&#x3C;'<span class="pl-en">a</span>, <span class="pl-en">T</span>>(<span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">marker</span><span class="pl-k">::</span><span class="pl-en">PhantomData</span>&#x3C;<span class="pl-k">&#x26;</span>'<span class="pl-en">a</span> <span class="pl-en">T</span>>);
<span class="pl-k">impl</span>&#x3C;'<span class="pl-en">a</span>, <span class="pl-en">T</span>> <span class="pl-en">Container</span>&#x3C;'<span class="pl-en">a</span>, <span class="pl-en">T</span>> <span class="pl-k">where</span> <span class="pl-en">T</span><span class="pl-k">:</span> <span class="pl-en">MyTrait</span>&#x3C;'<span class="pl-en">a</span>> {
    <span class="pl-k">pub</span> <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">proxy_callback</span>() <span class="pl-k">-></span> <span class="pl-en">i32</span> {
        <span class="pl-en">T</span><span class="pl-k">::</span><span class="pl-c1">CALLBACK_1</span>()
    }
}
<span class="pl-k">pub</span> <span class="pl-k">fn</span> <span class="pl-en">main</span>() <span class="pl-k">-></span> <span class="pl-en">i32</span> {
    <span class="pl-k">unsafe</span> {
        <span class="pl-en">Container</span><span class="pl-k">::</span>&#x3C;'<span class="pl-en">_</span>, <span class="pl-en">MyStruct</span>><span class="pl-k">::</span><span class="pl-en">proxy_callback</span>()
    }
}
</pre></div>
<p>Which produces this assembly:</p>
<pre><code class="language-nasm">example::main::h11eebe12cad5e117:
        mov     dword ptr [rsp - 8], 5
        lea     rax, [rsp - 8]
        mov     eax, dword ptr [rsp - 8]
        mov     dword ptr [rsp - 4], 15
        lea     rcx, [rsp - 4]
        imul    eax, dword ptr [rsp - 4]
        ret
</code></pre>
<p>Again, the entire function was inlined, even though a <a href="https://doc.rust-lang.org/std/keyword.dyn.html"><code>dyn</code>-trait</a> is used
the compiler can figure out that it should/can be inlined.</p>
<p>This may seem a bit useless, since the only difference between the pre- and post-abstraction
code is having the function connected to a struct, but using that, better abstractions can be provided.</p>
<hr>
<h3>Better function signatures</h3>
<p>Looking again at the function pointer that will be invoked for <code>lseek</code>:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">proc_lseek</span>(
    <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
    <span class="pl-smi">offset</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
    <span class="pl-smi">whence</span><span class="pl-k">:</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_int</span>,
) <span class="pl-k">-></span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span> {
    <span class="pl-k">...</span>
}
</pre></div>
<p>It can be described as a pure-rust-function like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">proc_lseek</span>(<span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
    <span class="pl-smi">offset</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
    <span class="pl-smi">whence</span><span class="pl-k">:</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_int</span>) <span class="pl-k">-></span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>;
</pre></div>
<p>Or even better like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-c">/// lseek valid variants [See the lseek docs for more detail](https://man7.org/linux/man-pages/man2/lseek.2.html)</span>
#[repr(<span class="pl-en">u32</span>)]
<span class="pl-k">pub</span> <span class="pl-k">enum</span> <span class="pl-en">Whence</span> {
<span class="pl-c">    /// See above doc link</span>
    <span class="pl-en">SeekSet</span> <span class="pl-k">=</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-c1">SEEK_SET</span>,
<span class="pl-c">    /// See above doc link</span>
    <span class="pl-en">SeekCur</span> <span class="pl-k">=</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-c1">SEEK_CUR</span>,
<span class="pl-c">    /// See above doc link</span>
    <span class="pl-en">SeekEnd</span> <span class="pl-k">=</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-c1">SEEK_END</span>,
<span class="pl-c">    /// See above doc link</span>
    <span class="pl-en">SeekData</span> <span class="pl-k">=</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-c1">SEEK_DATA</span>,
<span class="pl-c">    /// See above doc link</span>
    <span class="pl-en">SeekHole</span> <span class="pl-k">=</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-c1">SEEK_HOLE</span>,
}
<span class="pl-k">impl</span> <span class="pl-en">TryFrom</span>&#x3C;<span class="pl-en">u32</span>> <span class="pl-k">for</span> <span class="pl-en">Whence</span> {
    <span class="pl-k">type</span> <span class="pl-en">Error</span> <span class="pl-k">=</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">error</span><span class="pl-k">::</span><span class="pl-en">Error</span>;
    <span class="pl-k">fn</span> <span class="pl-en">try_from</span>(<span class="pl-smi">value</span><span class="pl-k">:</span> <span class="pl-en">u32</span>) <span class="pl-k">-></span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">result</span><span class="pl-k">::</span><span class="pl-en">Result</span>&#x3C;<span class="pl-c1">Self</span>, <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">Error</span>> {
        <span class="pl-en">Ok</span>(<span class="pl-k">match</span> <span class="pl-smi">value</span> {
            <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-c1">SEEK_SET</span> <span class="pl-k">=></span> <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">SeekSet</span>,
            <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-c1">SEEK_CUR</span> <span class="pl-k">=></span> <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">SeekCur</span>,
            <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-c1">SEEK_END</span> <span class="pl-k">=></span> <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">SeekEnd</span>,
            <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-c1">SEEK_DATA</span> <span class="pl-k">=></span> <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">SeekData</span>,
            <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-c1">SEEK_HOLE</span> <span class="pl-k">=></span> <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">SeekHole</span>,
            <span class="pl-smi">_</span> <span class="pl-k">=></span> <span class="pl-k">return</span> <span class="pl-en">Err</span>(<span class="pl-c1">EINVAL</span>),
        })
    }
}
<span class="pl-k">fn</span> <span class="pl-en">proc_lseek</span>(<span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
    <span class="pl-smi">offset</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
    <span class="pl-smi">whence</span><span class="pl-k">:</span> <span class="pl-en">Whence</span>) <span class="pl-k">-></span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>;
</pre></div>
<p>Or even better, since even though the bindings specify a <code>*mut</code>, <a href="https://doc.rust-lang.org/nomicon/aliasing.html">converting that to a mutable reference
is likely going to cause UB</a>, but converting it to
an immutable reference is slightly more likely be safe.</p>
<p>Postfix edit: It's definitely not guaranteed to be safe (more on that below).</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">proc_lseek</span>(<span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span><span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
    <span class="pl-smi">offset</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
    <span class="pl-smi">whence</span><span class="pl-k">:</span> <span class="pl-en">Whence</span>) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;<span class="pl-smi">kernel</span><span class="pl-k">::</span><span class="pl-smi">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>>;
</pre></div>
<hr>
<p>Making a safer abstraction over the bindings struct <code>file</code> would be even better, ~~but deemed out of scope,
the rust-api now communicates that lseek takes a reference to a file that should not be mutated
(it can safely be mutated with synchronization, again out of scope)~~, an offset, and a <code>Whence</code>-enum which
can only be one of 5 values.</p>
<hr>
<h3>A safe reference to the <code>file</code>-struct</h3>
<p>When working with unsafe and raw pointers in <code>Rust</code> it's easy to get it wrong, it's best to keep <code>Rust</code>'s aliasing
rules top of mind when trying:</p>
<blockquote>
<p>There can only be one mutable reference and no other references to some object, alternatively there can be
however many immutable reference to an object at a given time.
The data behind an immutable reference must not change while holding the reference.</p>
</blockquote>
<p>What this means in practice is that if an immutable reference is taken to a <code>file</code>-struct backed by a pointer
that the kernel provides, and that pointer is changed while holding the reference, that's UB.</p>
<p>There is something to be said about how big of a problem that actually is, it depends on the situation. As a general rule,
avoiding UB will save you from a headache now and in the future, so how can the <code>file</code>-struct be made safe?</p>
<p>Sometimes the kernel code guarantees operation serialization when reading a file, looking at the handler for
the <a href="https://man7.org/linux/man-pages/man2/read.2.html">read syscall</a> for example <a href="https://github.com/MarcusGrass/linux/blob/mg/proc-fs/fs/read_write.c#L608">(it's here)</a>
and looks like this:</p>
<div class="highlight highlight-c"><pre><span class="pl-c1">ssize_t</span> <span class="pl-en">ksys_read</span>(<span class="pl-k">unsigned</span> <span class="pl-k">int</span> fd, <span class="pl-k">char</span> __user *buf, <span class="pl-c1">size_t</span> count)
{
	<span class="pl-k">struct</span> fd f = <span class="pl-c1">fdget_pos</span>(fd);
	<span class="pl-c1">ssize_t</span> ret = -EBADF;
	<span class="pl-k">if</span> (f.<span class="pl-smi">file</span>) {
		<span class="pl-c1">loff_t</span> pos, *ppos = <span class="pl-c1">file_ppos</span>(f.<span class="pl-smi">file</span>);
		<span class="pl-k">if</span> (ppos) {
			pos = *ppos;
			ppos = &#x26;pos;
		}
		ret = <span class="pl-c1">vfs_read</span>(f.<span class="pl-smi">file</span>, buf, count, ppos);
		<span class="pl-k">if</span> (ret >= <span class="pl-c1">0</span> &#x26;&#x26; ppos)
			f.<span class="pl-smi">file</span>-><span class="pl-smi">f_pos</span> = pos;
		<span class="pl-c1">fdput_pos</span>(f);
	}
	<span class="pl-k">return</span> ret;
}
<span class="pl-en">SYSCALL_DEFINE3</span>(read, <span class="pl-k">unsigned</span> <span class="pl-k">int</span>, fd, <span class="pl-k">char</span> __user *, buf, <span class="pl-c1">size_t</span>, count)
{
	<span class="pl-k">return</span> <span class="pl-c1">ksys_read</span>(fd, buf, count);
}
</pre></div>
<p>A process can enter this syscall-handler with (theoretically) limitless concurrency.</p>
<p><code>vfs_read</code> will call the <code>proc_open</code>-handler that was defined, both with a pointer to the <code>file</code>, and
a pointer to the <code>file</code>'s offset-field. That means that if <code>Rust</code>-code is holding a reference to the file
and mutating the pointer at the same time, that's UB (oops).</p>
<p>There's a way of sidestepping this issue, working directly with the pointer:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">pub</span> <span class="pl-k">struct</span> <span class="pl-en">ProcOpFileHandle</span>(<span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ptr</span><span class="pl-k">::</span><span class="pl-en">NonNull</span>&#x3C;<span class="pl-smi">kernel</span><span class="pl-k">::</span><span class="pl-smi">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>>);
<span class="pl-k">impl</span> <span class="pl-en">ProcOpFileHandle</span> {
<span class="pl-c">    /// Gets the file flags</span>
    <span class="pl-k">pub</span> <span class="pl-k">fn</span> <span class="pl-en">get_flags</span>(<span class="pl-k">&#x26;</span><span class="pl-c1">self</span>) <span class="pl-k">-></span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_uint</span> {
        <span class="pl-k">unsafe</span> {
<span class="pl-c">            // Safety: flags are only set on open, any time</span>
<span class="pl-c">            // code gets here it's not going to be modified anymore</span>
            <span class="pl-k">let</span> <span class="pl-smi">flags_offset</span> <span class="pl-k">=</span> <span class="pl-en">offset_of!</span>(<span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>, <span class="pl-smi">f_flags</span>);
            <span class="pl-c1">self</span><span class="pl-k">.</span><span class="pl-c1">0</span>
                <span class="pl-k">.</span><span class="pl-en">cast</span><span class="pl-k">::</span>&#x3C;<span class="pl-en">u8</span>>()
                <span class="pl-k">.</span><span class="pl-en">add</span>(<span class="pl-smi">flags_offset</span>)
                <span class="pl-k">.</span><span class="pl-en">cast</span><span class="pl-k">::</span>&#x3C;<span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_uint</span>>()
                <span class="pl-k">.</span><span class="pl-en">read</span>()
        }
    }
    <span class="pl-k">fn</span> <span class="pl-en">pos_ptr</span>(<span class="pl-k">&#x26;</span><span class="pl-c1">self</span>) <span class="pl-k">-></span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ptr</span><span class="pl-k">::</span><span class="pl-en">NonNull</span>&#x3C;<span class="pl-smi">kernel</span><span class="pl-k">::</span><span class="pl-smi">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>> {
        <span class="pl-k">unsafe</span> {
            <span class="pl-k">let</span> <span class="pl-smi">pos_offset</span> <span class="pl-k">=</span> <span class="pl-en">offset_of!</span>(<span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>, <span class="pl-smi">f_pos</span>);
            <span class="pl-c1">self</span><span class="pl-k">.</span><span class="pl-c1">0</span>
                <span class="pl-k">.</span><span class="pl-en">cast</span><span class="pl-k">::</span>&#x3C;<span class="pl-en">u8</span>>()
                <span class="pl-k">.</span><span class="pl-en">add</span>(<span class="pl-smi">pos_offset</span>)
                <span class="pl-k">.</span><span class="pl-en">cast</span><span class="pl-k">::</span>&#x3C;<span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>>()
        }
    }
<span class="pl-c">    /// Reading the position is inescapably subject to raciness.  </span>
<span class="pl-c">    /// The kernel will, on this file-pointer, update position after each read and write,</span>
<span class="pl-c">    /// see ksys_read, ksys_write at read_write.c.  </span>
<span class="pl-c">    /// If the file is opened with f_mode `FMODE_ATOMIC_POS`, the proc-function is run under</span>
<span class="pl-c">    /// a pos-lock if needed, in which case this is safe from data-races.  </span>
<span class="pl-c">    /// Which means its up to the user to make sure concurrent read-writes doesn't happen if</span>
<span class="pl-c">    /// they want the offset to make sense.</span>
<span class="pl-c">    /// # Safety:</span>
<span class="pl-c">    /// This number may or may not make any sense, bounds checking is still necessary</span>
<span class="pl-c">    /// to retain safety</span>
    <span class="pl-k">pub</span> <span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">read_pos_unsync</span>(<span class="pl-k">&#x26;</span><span class="pl-c1">self</span>) <span class="pl-k">-></span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span> {
        <span class="pl-k">unsafe</span> { <span class="pl-c1">self</span><span class="pl-k">.</span><span class="pl-en">pos_ptr</span>()<span class="pl-k">.</span><span class="pl-en">read</span>() }
    }
<span class="pl-c">    /// Same raciness problems as [`Self::read_pos_unsync`].</span>
<span class="pl-c">    /// # Safety:</span>
<span class="pl-c">    /// This number may or may not make any sense, bounds checking is still necessary</span>
<span class="pl-c">    /// to retain safety</span>
    <span class="pl-k">pub</span> <span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">write_pos_unsync</span>(<span class="pl-k">&#x26;</span><span class="pl-c1">self</span>, <span class="pl-smi">offset</span><span class="pl-k">:</span> <span class="pl-smi">loff_t</span>) {
        <span class="pl-k">unsafe</span> {
            <span class="pl-c1">self</span><span class="pl-k">.</span><span class="pl-en">pos_ptr</span>()<span class="pl-k">.</span><span class="pl-en">write</span>(<span class="pl-smi">offset</span>);
        }
    }
}
</pre></div>
<p>In this case the <code>Rust</code>-code does not take any reference, and thus side-steps the aliasing-problems completely,
instead using pointer-arithmetic to find the correct field on the <code>file</code>-struct, and reading/writing that directly.</p>
<h4>Data-races</h4>
<p>If the comments were read another problem has now become apparent, there's a
<a href="https://en.wikipedia.org/wiki/Race_condition#Data_race">data-race</a> if there isn't exclusive access
to the pos-pointer.</p>
<p>Looking back at the <code>C</code>-code:</p>
<p>In <code>ksys_read</code>, <code>fdget_pos(fd)</code> was <a href="https://github.com/MarcusGrass/linux/blob/mg/proc-fs/fs/read_write.c#L610">invoked here</a>.</p>
<p><code>fdget_pos</code> looks like this:</p>
<div class="highlight highlight-c"><pre><span class="pl-k">static</span> <span class="pl-k">inline</span> <span class="pl-k">struct</span> fd <span class="pl-en">fdget_pos</span>(<span class="pl-k">int</span> fd)
{
	<span class="pl-k">return</span> <span class="pl-c1">__to_fd</span>(<span class="pl-c1">__fdget_pos</span>(fd));
}
</pre></div>
<p>It proxies the call to <code>__fdget_pos</code> and then converts the result to an <code>fd</code>.</p>
<p><code>__fdget_pos</code> is defined <a href="https://github.com/MarcusGrass/linux/blob/mg/proc-fs/fs/file.c#L1180">here in file.c</a></p>
<div class="highlight highlight-c"><pre><span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-en">__fdget_pos</span>(<span class="pl-k">unsigned</span> <span class="pl-k">int</span> fd)
{
	<span class="pl-k">unsigned</span> <span class="pl-k">long</span> v = <span class="pl-c1">__fdget</span>(fd);
	<span class="pl-k">struct</span> file *file = (<span class="pl-k">struct</span> file *)(v &#x26; ~<span class="pl-c1">3</span>);
	<span class="pl-k">if</span> (file &#x26;&#x26; <span class="pl-c1">file_needs_f_pos_lock</span>(file)) {
		v |= FDPUT_POS_UNLOCK;
		<span class="pl-c1">mutex_lock</span>(&#x26;file-><span class="pl-smi">f_pos_lock</span>);
	}
	<span class="pl-k">return</span> v;
}
</pre></div>
<p>The code implies that sometimes a <code>file</code> is determined to need a <code>pos_lock</code>, digging into
<code>file_needs_f_pos_lock</code> that's defined <a href="https://github.com/MarcusGrass/linux/blob/mg/proc-fs/fs/file.c#L1174">here</a>:</p>
<div class="highlight highlight-c"><pre><span class="pl-c">/*</span>
<span class="pl-c"> * Try to avoid f_pos locking. We only need it if the</span>
<span class="pl-c"> * file is marked for FMODE_ATOMIC_POS, and it can be</span>
<span class="pl-c"> * accessed multiple ways.</span>
<span class="pl-c"> *</span>
<span class="pl-c"> * Always do it for directories, because pidfd_getfd()</span>
<span class="pl-c"> * can make a file accessible even if it otherwise would</span>
<span class="pl-c"> * not be, and for directories this is a correctness</span>
<span class="pl-c"> * issue, not a "POSIX requirement".</span>
<span class="pl-c"> */</span>
<span class="pl-k">static</span> <span class="pl-k">inline</span> <span class="pl-k">bool</span> <span class="pl-en">file_needs_f_pos_lock</span>(<span class="pl-k">struct</span> file *file)
{
	<span class="pl-k">return</span> (file-><span class="pl-smi">f_mode</span> &#x26; FMODE_ATOMIC_POS) &#x26;&#x26;
		(<span class="pl-c1">file_count</span>(file) > <span class="pl-c1">1</span> || file-><span class="pl-smi">f_op</span>-><span class="pl-smi">iterate_shared</span>);
}
</pre></div>
<p>In short: If the <code>file</code> has <code>f_mode</code> <code>FMODE_ATOMIC_POS</code>, and (there are multiple open handles or
the <code>file</code> has the file operation <code>iterate_shared</code> defined), then the <code>pos</code> will be locked.</p>
<p>The kernel generally doesn't mess with the flags, they are set by the user, so there is no guarantee that
the <code>file</code>'s <code>pos</code> won't be shared while the <code>Rust</code>-code is using it.</p>
<h4>An acceptable data race</h4>
<p>In practice, for the <code>pos</code>-field, this means that when reading to it, the <code>Rust</code>-code may get an old-value,
or worse, an incomplete or unexpected value, it's undefined.</p>
<p>That issue cannot be worked around and in some cases directly reading the value would be UB,
for example if the <code>Rust</code>-code expects a struct where all bit-patterns aren't valid.</p>
<p>In the case of the <code>proc</code>-handler, and <code>pos</code>-field, the <code>Rust</code>-code is trying to read an <code>loff_t</code> which on
<code>x86_64</code> is an <code>i64</code>, but on other platforms it's an equally simple number.</p>
<p><code>loff_t</code> is valid for all bit-patterns, so reading it is not UB by itself, it's correctly initialized memory,
but the value of it may be garbage due to simultaneous modification by a different thread.</p>
<p>As the above <code>Rust</code>-code comments describe, the read value shall never be trusted and always be subject to
validation, the reading itself is <code>safe</code>, but the function is marked <code>unsafe</code> anyway to make that fact extra clear.</p>
<p>This means that it's up to the user to properly synchronize access, not doing so will not cause UB, but
may cause concurrency bugs.</p>
<h4>Handling reading racy data for more complex structs</h4>
<p>Since reading <code>pos</code> from <code>file</code> happened to be simple, ways of handling more complex cases weren't explained.
If <code>Rust</code>-code wants to read some struct from a pointer that could contain any bit-pattern, and the
struct cannot tolerate any bit-pattern, the programmer would need to read into something else first.</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">struct</span> <span class="pl-en">MyStruct</span> {
  <span class="pl-smi">field_a</span><span class="pl-k">:</span> <span class="pl-en">Inner</span>,
  <span class="pl-smi">field_b</span><span class="pl-k">:</span> <span class="pl-en">OtherThing</span>,
}
<span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">read_my_struct_from_pointer</span>(<span class="pl-smi">ptr</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">MyStruct</span>) <span class="pl-k">-></span> <span class="pl-en">Option</span>&#x3C;<span class="pl-en">MyStruct</span>> {
<span class="pl-c">  // Comptime size of the struct in bytes</span>
  <span class="pl-k">const</span> <span class="pl-c1">LEN</span><span class="pl-k">:</span> <span class="pl-en">usize</span> <span class="pl-k">=</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">mem</span><span class="pl-k">::</span><span class="pl-en">size_of</span><span class="pl-k">::</span>&#x3C;<span class="pl-en">MyStruct</span>>();
<span class="pl-c">  // Zeroed byte-array that can hold that number of bytes</span>
  <span class="pl-k">let</span> <span class="pl-k">mut</span> <span class="pl-smi">bytes</span> <span class="pl-k">=</span> [<span class="pl-c1">0</span><span class="pl-en">u8</span>; <span class="pl-c1">LEN</span>];
  <span class="pl-k">let</span> <span class="pl-smi">byte_ptr</span> <span class="pl-k">=</span> <span class="pl-smi">bytes</span><span class="pl-k">.</span><span class="pl-en">as_mut_ptr</span>();
<span class="pl-c">  // Copy the raw data into the byte-array</span>
  <span class="pl-smi">ptr</span><span class="pl-k">.</span><span class="pl-en">cast</span><span class="pl-k">::</span>&#x3C;<span class="pl-en">u8</span>>()
          <span class="pl-k">.</span><span class="pl-en">copy_to_nonoverlapping</span>(<span class="pl-smi">byte_ptr</span>, <span class="pl-c1">LEN</span>);
<span class="pl-c">  // Validate that the data is well-formed</span>
  <span class="pl-en">MyStruct</span><span class="pl-k">::</span><span class="pl-en">try_from_bytes</span>(<span class="pl-smi">bytes</span>);
}
</pre></div>
<p>That may look trivial, but implementing <code>try_from_bytes</code> is where memory-layout-requirements have to be checked,
there are crates for that, like <a href="https://docs.rs/bytemuck/latest/bytemuck/">bytemuck</a>, if encountering that
kind of situation looking there is a good start.</p>
<hr>
<h3>Back to abstracting</h3>
<p>Now the signature looks like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">plseek</span>(
    <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">&#x26;mut</span> <span class="pl-en">ProcOpFileHandle</span>,
    <span class="pl-smi">offset</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
    <span class="pl-smi">whence</span><span class="pl-k">:</span> <span class="pl-en">Whence</span>,
) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;<span class="pl-smi">kernel</span><span class="pl-k">::</span><span class="pl-smi">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>>;
</pre></div>
<p>There's a mutable reference to <code>ProcOpFileHandle</code> which wraps a raw <code>file</code>-pointer.
It's marked as mutable to prevent race-conditions by shared modifications, they are inescapable since
the inner pointer is shared with <code>C</code>-code, but there's no reason to make a bad problem worse.</p>
<hr>
<h3>Wrapping the <code>unsafe extern "C" fn</code></h3>
<p>Continuing, something needs to wrap this <code>Rust</code>-function, validate that <code>Whence</code> can be converted from the provided <code>int</code>
from the <code>C</code>-style function, check that the file-pointer is non-null and create a <code>ProcOpsFileHandle</code>, and lastly handle
the <code>Result</code>.</p>
<p>Here's an example of how that could look:</p>
<div class="highlight highlight-rust"><pre><span class="pl-c">/// Raw C-entrypoint</span>
<span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">proc_lseek</span>(
    <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
    <span class="pl-smi">offset</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
    <span class="pl-smi">whence</span><span class="pl-k">:</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_int</span>,
) <span class="pl-k">-></span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span> {
    <span class="pl-k">let</span> <span class="pl-en">Ok</span>(<span class="pl-smi">whence_u32</span>) <span class="pl-k">=</span> <span class="pl-en">u32</span><span class="pl-k">::</span><span class="pl-en">try_from</span>(<span class="pl-smi">whence</span>) <span class="pl-k">else</span> {
        <span class="pl-k">return</span> <span class="pl-c1">EINVAL</span><span class="pl-k">.</span><span class="pl-en">to_errno</span>()<span class="pl-k">.</span><span class="pl-en">into</span>();
    };
    <span class="pl-k">let</span> <span class="pl-en">Ok</span>(<span class="pl-smi">whence</span>) <span class="pl-k">=</span> <span class="pl-en">Whence</span><span class="pl-k">::</span><span class="pl-en">try_from</span>(<span class="pl-smi">whence_u32</span>) <span class="pl-k">else</span> {
        <span class="pl-k">return</span> <span class="pl-c1">EINVAL</span><span class="pl-k">.</span><span class="pl-en">to_errno</span>()<span class="pl-k">.</span><span class="pl-en">into</span>();
    };
    <span class="pl-k">let</span> <span class="pl-k">mut</span> <span class="pl-smi">file_ref</span> <span class="pl-k">=</span> <span class="pl-k">if</span> <span class="pl-k">let</span> <span class="pl-en">Some</span>(<span class="pl-smi">ptr</span>) <span class="pl-k">=</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ptr</span><span class="pl-k">::</span><span class="pl-en">NonNull</span><span class="pl-k">::</span><span class="pl-en">new</span>(<span class="pl-smi">file</span>) {
        <span class="pl-en">ProcOpFileHandle</span>(<span class="pl-smi">ptr</span>)
    } <span class="pl-k">else</span> {
        <span class="pl-k">return</span> <span class="pl-c1">EINVAL</span><span class="pl-k">.</span><span class="pl-en">to_errno</span>()<span class="pl-k">.</span><span class="pl-en">into</span>();
    };
    <span class="pl-k">match</span> (<span class="pl-en">T</span><span class="pl-k">::</span><span class="pl-c1">LSEEK</span>)(<span class="pl-k">&#x26;mut</span> <span class="pl-smi">file_ref</span>, <span class="pl-smi">offset</span>, <span class="pl-smi">whence</span>) {
        <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">result</span><span class="pl-k">::</span><span class="pl-en">Result</span><span class="pl-k">::</span><span class="pl-en">Ok</span>(<span class="pl-smi">offs</span>) <span class="pl-k">=></span> <span class="pl-smi">offs</span>,
        <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">result</span><span class="pl-k">::</span><span class="pl-en">Result</span><span class="pl-k">::</span><span class="pl-en">Err</span>(<span class="pl-smi">e</span>) <span class="pl-k">=></span> {
            <span class="pl-k">return</span> <span class="pl-smi">e</span><span class="pl-k">.</span><span class="pl-en">to_errno</span>()<span class="pl-k">.</span><span class="pl-en">into</span>();
        }
    }
}
</pre></div>
<p>The <code>T::LSEEK</code> comes from a generic bound, as with the minimal example, this function-pointer comes from
a struct which implements a trait.</p>
<p>The definition of the generated <code>proc_ops</code> looks like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">pub</span> <span class="pl-k">struct</span> <span class="pl-smi">proc_ops</span> {
    <span class="pl-k">pub</span> <span class="pl-smi">proc_flags</span><span class="pl-k">:</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_uint</span>,
    <span class="pl-k">pub</span> <span class="pl-smi">proc_open</span><span class="pl-k">:</span> <span class="pl-k">::</span><span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">option</span><span class="pl-k">::</span><span class="pl-en">Option</span>&#x3C;
        <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> "<span class="pl-en">C</span>" <span class="pl-k">fn</span>(<span class="pl-smi">arg1</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">inode</span>, <span class="pl-smi">arg2</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">file</span>) <span class="pl-k">-></span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_int</span>,
    >,
    <span class="pl-k">pub</span> <span class="pl-smi">proc_read</span><span class="pl-k">:</span> <span class="pl-k">::</span><span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">option</span><span class="pl-k">::</span><span class="pl-en">Option</span>&#x3C;
        <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> "<span class="pl-en">C</span>" <span class="pl-k">fn</span>(
            <span class="pl-smi">arg1</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">file</span>,
            <span class="pl-smi">arg2</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_char</span>,
            <span class="pl-smi">arg3</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
            <span class="pl-smi">arg4</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">loff_t</span>,
        ) <span class="pl-k">-></span> <span class="pl-en">isize</span>,
    >,
    <span class="pl-k">pub</span> <span class="pl-smi">proc_read_iter</span><span class="pl-k">:</span> <span class="pl-k">::</span><span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">option</span><span class="pl-k">::</span><span class="pl-en">Option</span>&#x3C;
        <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> "<span class="pl-en">C</span>" <span class="pl-k">fn</span>(<span class="pl-smi">arg1</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">kiocb</span>, <span class="pl-smi">arg2</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">iov_iter</span>) <span class="pl-k">-></span> <span class="pl-en">isize</span>,
    >,
    <span class="pl-k">pub</span> <span class="pl-smi">proc_write</span><span class="pl-k">:</span> <span class="pl-k">::</span><span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">option</span><span class="pl-k">::</span><span class="pl-en">Option</span>&#x3C;
        <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> "<span class="pl-en">C</span>" <span class="pl-k">fn</span>(
            <span class="pl-smi">arg1</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">file</span>,
            <span class="pl-smi">arg2</span><span class="pl-k">:</span> <span class="pl-k">*const</span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_char</span>,
            <span class="pl-smi">arg3</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
            <span class="pl-smi">arg4</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">loff_t</span>,
        ) <span class="pl-k">-></span> <span class="pl-en">isize</span>,
    >,
    <span class="pl-k">pub</span> <span class="pl-smi">proc_lseek</span><span class="pl-k">:</span> <span class="pl-k">::</span><span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">option</span><span class="pl-k">::</span><span class="pl-en">Option</span>&#x3C;
        <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> "<span class="pl-en">C</span>" <span class="pl-k">fn</span>(<span class="pl-smi">arg1</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">file</span>, <span class="pl-smi">arg2</span><span class="pl-k">:</span> <span class="pl-smi">loff_t</span>, <span class="pl-smi">arg3</span><span class="pl-k">:</span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_int</span>) <span class="pl-k">-></span> <span class="pl-smi">loff_t</span>,
    >,
    <span class="pl-k">pub</span> <span class="pl-smi">proc_release</span><span class="pl-k">:</span> <span class="pl-k">::</span><span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">option</span><span class="pl-k">::</span><span class="pl-en">Option</span>&#x3C;
        <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> "<span class="pl-en">C</span>" <span class="pl-k">fn</span>(<span class="pl-smi">arg1</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">inode</span>, <span class="pl-smi">arg2</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">file</span>) <span class="pl-k">-></span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_int</span>,
    >,
    <span class="pl-k">pub</span> <span class="pl-smi">proc_poll</span><span class="pl-k">:</span> <span class="pl-k">::</span><span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">option</span><span class="pl-k">::</span><span class="pl-en">Option</span>&#x3C;
        <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> "<span class="pl-en">C</span>" <span class="pl-k">fn</span>(<span class="pl-smi">arg1</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">file</span>, <span class="pl-smi">arg2</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">poll_table_struct</span>) <span class="pl-k">-></span> <span class="pl-smi">__poll_t</span>,
    >,
    <span class="pl-k">pub</span> <span class="pl-smi">proc_ioctl</span><span class="pl-k">:</span> <span class="pl-k">::</span><span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">option</span><span class="pl-k">::</span><span class="pl-en">Option</span>&#x3C;
        <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> "<span class="pl-en">C</span>" <span class="pl-k">fn</span>(
            <span class="pl-smi">arg1</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">file</span>,
            <span class="pl-smi">arg2</span><span class="pl-k">:</span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_uint</span>,
            <span class="pl-smi">arg3</span><span class="pl-k">:</span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_ulong</span>,
        ) <span class="pl-k">-></span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_long</span>,
    >,
    <span class="pl-k">pub</span> <span class="pl-smi">proc_compat_ioctl</span><span class="pl-k">:</span> <span class="pl-k">::</span><span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">option</span><span class="pl-k">::</span><span class="pl-en">Option</span>&#x3C;
        <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> "<span class="pl-en">C</span>" <span class="pl-k">fn</span>(
            <span class="pl-smi">arg1</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">file</span>,
            <span class="pl-smi">arg2</span><span class="pl-k">:</span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_uint</span>,
            <span class="pl-smi">arg3</span><span class="pl-k">:</span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_ulong</span>,
        ) <span class="pl-k">-></span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_long</span>,
    >,
    <span class="pl-k">pub</span> <span class="pl-smi">proc_mmap</span><span class="pl-k">:</span> <span class="pl-k">::</span><span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">option</span><span class="pl-k">::</span><span class="pl-en">Option</span>&#x3C;
        <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> "<span class="pl-en">C</span>" <span class="pl-k">fn</span>(<span class="pl-smi">arg1</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">file</span>, <span class="pl-smi">arg2</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">vm_area_struct</span>) <span class="pl-k">-></span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_int</span>,
    >,
    <span class="pl-k">pub</span> <span class="pl-smi">proc_get_unmapped_area</span><span class="pl-k">:</span> <span class="pl-k">::</span><span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">option</span><span class="pl-k">::</span><span class="pl-en">Option</span>&#x3C;
        <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> "<span class="pl-en">C</span>" <span class="pl-k">fn</span>(
            <span class="pl-smi">arg1</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-smi">file</span>,
            <span class="pl-smi">arg2</span><span class="pl-k">:</span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_ulong</span>,
            <span class="pl-smi">arg3</span><span class="pl-k">:</span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_ulong</span>,
            <span class="pl-smi">arg4</span><span class="pl-k">:</span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_ulong</span>,
            <span class="pl-smi">arg5</span><span class="pl-k">:</span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_ulong</span>,
        ) <span class="pl-k">-></span> <span class="pl-smi">core</span><span class="pl-k">::</span><span class="pl-smi">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_ulong</span>,
    >,
}
</pre></div>
<p>It's a struct containing a bunch of optional function-pointers. Here's what it looks after abstracting most of the <code>C</code>-parts away
(only implementing <code>open</code>, <code>read</code>, <code>write</code>, and <code>lseek</code>).</p>
<div class="highlight highlight-rust"><pre><span class="pl-c">/// Type alias for open function signature</span>
<span class="pl-k">pub</span> <span class="pl-k">type</span> <span class="pl-en">ProcOpen</span>&#x3C;'<span class="pl-en">a</span>> <span class="pl-k">=</span> <span class="pl-k">&#x26;</span>'<span class="pl-en">a</span> <span class="pl-k">dyn</span> <span class="pl-en">Fn</span>(<span class="pl-k">&#x26;mut</span> <span class="pl-en">ProcOpFileHandle</span>) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;<span class="pl-en">i32</span>>;
<span class="pl-c">/// Type alias for read function signature</span>
<span class="pl-k">pub</span> <span class="pl-k">type</span> <span class="pl-en">ProcRead</span>&#x3C;'<span class="pl-en">a</span>> <span class="pl-k">=</span>
<span class="pl-k">&#x26;</span>'<span class="pl-en">a</span> <span class="pl-k">dyn</span> <span class="pl-en">Fn</span>(<span class="pl-k">&#x26;mut</span> <span class="pl-en">ProcOpFileHandle</span>, <span class="pl-en">UserSliceWriter</span>, <span class="pl-smi">loff_t</span>) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;(<span class="pl-en">usize</span>, <span class="pl-en">usize</span>)>;
<span class="pl-c">/// Type alias for write function signature</span>
<span class="pl-k">pub</span> <span class="pl-k">type</span> <span class="pl-en">ProcWrite</span>&#x3C;'<span class="pl-en">a</span>> <span class="pl-k">=</span>
<span class="pl-k">&#x26;</span>'<span class="pl-en">a</span> <span class="pl-k">dyn</span> <span class="pl-en">Fn</span>(<span class="pl-k">&#x26;mut</span> <span class="pl-en">ProcOpFileHandle</span>, <span class="pl-en">UserSliceReader</span>, <span class="pl-smi">loff_t</span>) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;(<span class="pl-en">usize</span>, <span class="pl-en">usize</span>)>;
<span class="pl-c">/// Type alias for lseek function signature</span>
<span class="pl-k">pub</span> <span class="pl-k">type</span> <span class="pl-en">ProcLseek</span>&#x3C;'<span class="pl-en">a</span>> <span class="pl-k">=</span> <span class="pl-k">&#x26;</span>'<span class="pl-en">a</span> <span class="pl-k">dyn</span> <span class="pl-en">Fn</span>(<span class="pl-k">&#x26;mut</span> <span class="pl-en">ProcOpFileHandle</span>, <span class="pl-smi">loff_t</span>, <span class="pl-en">Whence</span>) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;<span class="pl-smi">loff_t</span>>;
<span class="pl-c">/// Proc file ops handler</span>
<span class="pl-k">pub</span> <span class="pl-k">trait</span> <span class="pl-en">ProcHandler</span>&#x3C;'<span class="pl-en">a</span>> {
<span class="pl-c">    /// Open handler</span>
    <span class="pl-k">const</span> <span class="pl-c1">OPEN</span><span class="pl-k">:</span> <span class="pl-en">ProcOpen</span>&#x3C;'<span class="pl-en">a</span>>;
<span class="pl-c">    /// Read handler</span>
    <span class="pl-k">const</span> <span class="pl-c1">READ</span><span class="pl-k">:</span> <span class="pl-en">ProcRead</span>&#x3C;'<span class="pl-en">a</span>>;
<span class="pl-c">    /// Write handler</span>
    <span class="pl-k">const</span> <span class="pl-c1">WRITE</span><span class="pl-k">:</span> <span class="pl-en">ProcWrite</span>&#x3C;'<span class="pl-en">a</span>>;
<span class="pl-c">    /// Lseek handler</span>
    <span class="pl-k">const</span> <span class="pl-c1">LSEEK</span><span class="pl-k">:</span> <span class="pl-en">ProcLseek</span>&#x3C;'<span class="pl-en">a</span>>;
}
<span class="pl-c">/// Wrapper for the kernel type `proc_ops`</span>
<span class="pl-c">/// Roughly a translation of the expected `extern "C"`-function pointers that</span>
<span class="pl-c">/// the kernel expects into Rust-functions with a few more helpful types.</span>
<span class="pl-k">pub</span> <span class="pl-k">struct</span> <span class="pl-en">ProcOps</span>&#x3C;'<span class="pl-en">a</span>, <span class="pl-en">T</span>>
<span class="pl-k">where</span>
    <span class="pl-en">T</span><span class="pl-k">:</span> <span class="pl-en">ProcHandler</span>&#x3C;'<span class="pl-en">static</span>>,
{
    <span class="pl-smi">ops</span><span class="pl-k">:</span> <span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">proc_ops</span>,
    <span class="pl-smi">_pd</span><span class="pl-k">:</span> <span class="pl-en">PhantomData</span>&#x3C;<span class="pl-k">&#x26;</span>'<span class="pl-en">a</span> <span class="pl-en">T</span>>,
}
<span class="pl-k">impl</span>&#x3C;'<span class="pl-en">a</span>, <span class="pl-en">T</span>> <span class="pl-en">ProcOps</span>&#x3C;'<span class="pl-en">a</span>, <span class="pl-en">T</span>>
<span class="pl-k">where</span>
    <span class="pl-en">T</span><span class="pl-k">:</span> <span class="pl-en">ProcHandler</span>&#x3C;'<span class="pl-en">static</span>>,
{
<span class="pl-c">    /// Create new ProcOps from a handler and flags</span>
    <span class="pl-k">pub</span> <span class="pl-k">const</span> <span class="pl-k">fn</span> <span class="pl-en">new</span>(<span class="pl-smi">proc_flags</span><span class="pl-k">:</span> <span class="pl-en">u32</span>) <span class="pl-k">-></span> <span class="pl-c1">Self</span> {
        <span class="pl-c1">Self</span> {
            <span class="pl-smi">ops</span><span class="pl-k">:</span> <span class="pl-smi">proc_ops</span> {
                <span class="pl-smi">proc_flags</span>,
                <span class="pl-smi">proc_open</span><span class="pl-k">:</span> <span class="pl-en">Some</span>(<span class="pl-en">ProcOps</span><span class="pl-k">::</span>&#x3C;'<span class="pl-en">a</span>, <span class="pl-en">T</span>><span class="pl-k">::</span><span class="pl-smi">proc_open</span>),
                <span class="pl-smi">proc_read</span><span class="pl-k">:</span> <span class="pl-en">Some</span>(<span class="pl-en">ProcOps</span><span class="pl-k">::</span>&#x3C;'<span class="pl-en">a</span>, <span class="pl-en">T</span>><span class="pl-k">::</span><span class="pl-smi">proc_read</span>),
                <span class="pl-smi">proc_read_iter</span><span class="pl-k">:</span> <span class="pl-en">None</span>,
                <span class="pl-smi">proc_write</span><span class="pl-k">:</span> <span class="pl-en">Some</span>(<span class="pl-en">ProcOps</span><span class="pl-k">::</span>&#x3C;'<span class="pl-en">a</span>, <span class="pl-en">T</span>><span class="pl-k">::</span><span class="pl-smi">proc_write</span>),
                <span class="pl-smi">proc_lseek</span><span class="pl-k">:</span> <span class="pl-en">Some</span>(<span class="pl-en">ProcOps</span><span class="pl-k">::</span>&#x3C;'<span class="pl-en">a</span>, <span class="pl-en">T</span>><span class="pl-k">::</span><span class="pl-smi">proc_lseek</span>),
                <span class="pl-smi">proc_release</span><span class="pl-k">:</span> <span class="pl-en">None</span>,
                <span class="pl-smi">proc_poll</span><span class="pl-k">:</span> <span class="pl-en">None</span>,
                <span class="pl-smi">proc_ioctl</span><span class="pl-k">:</span> <span class="pl-en">None</span>,
                <span class="pl-smi">proc_compat_ioctl</span><span class="pl-k">:</span> <span class="pl-en">None</span>,
                <span class="pl-smi">proc_mmap</span><span class="pl-k">:</span> <span class="pl-en">None</span>,
                <span class="pl-smi">proc_get_unmapped_area</span><span class="pl-k">:</span> <span class="pl-en">None</span>,
            },
            <span class="pl-smi">_pd</span><span class="pl-k">:</span> <span class="pl-en">PhantomData</span>,
        }
    }
    <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">proc_open</span>(
        <span class="pl-smi">inode</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">inode</span>,
        <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
    ) <span class="pl-k">-></span> <span class="pl-en">i32</span> {
        <span class="pl-k">...</span>
<span class="pl-c">        // Call T::OPEN </span>
        <span class="pl-k">...</span>
    }
    <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">proc_read</span>(
        <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
        <span class="pl-smi">buf</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_char</span>,
        <span class="pl-smi">buf_cap</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
        <span class="pl-smi">read_offset</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
    ) <span class="pl-k">-></span> <span class="pl-en">isize</span> {
        <span class="pl-k">...</span>
<span class="pl-c">        // Call T::READ </span>
        <span class="pl-k">...</span>
    }
    <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">proc_write</span>(
        <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
        <span class="pl-smi">buf</span><span class="pl-k">:</span> <span class="pl-k">*const</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_char</span>,
        <span class="pl-smi">buf_cap</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
        <span class="pl-smi">write_offset</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
    ) <span class="pl-k">-></span> <span class="pl-en">isize</span> {
        <span class="pl-k">...</span>
<span class="pl-c">        // Call T::WRITE </span>
        <span class="pl-k">...</span>
    }
    <span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">proc_lseek</span>(
        <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
        <span class="pl-smi">offset</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
        <span class="pl-smi">whence</span><span class="pl-k">:</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_int</span>,
    ) <span class="pl-k">-></span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span> {
        <span class="pl-k">...</span>
<span class="pl-c">        // Call T::LSEEK </span>
        <span class="pl-k">...</span>
    }
}
</pre></div>
<p>Some details are elided for brevity, the above code defines a trait <code>ProcHandler</code>, which contains
constants for each of the functions to be provided. Those constants are <code>'static</code>-references to rust functions.</p>
<p>Then it defines the <code>ProcOps</code>-struct, which is generic over <code>ProcHandler</code>, it defines the correct <code>C</code>-style
functions which do conversions and call the provided <code>ProcHandler</code>'s <code>'&#x26;static</code>-functions and return their results.</p>
<hr>
<p>Using this, the <code>C</code>-style proc_create function can get a <code>Rust</code>-abstraction taking that <code>ProcOps</code>-struct:</p>
<div class="highlight highlight-rust"><pre><span class="pl-c">/// Create a proc entry with the filename `name`</span>
<span class="pl-k">pub</span> <span class="pl-k">fn</span> <span class="pl-en">proc_create</span>&#x3C;'<span class="pl-en">a</span>, <span class="pl-en">T</span>>(
    <span class="pl-smi">name</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span>'<span class="pl-en">static</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">str</span><span class="pl-k">::</span><span class="pl-en">CStr</span>,
    <span class="pl-smi">mode</span><span class="pl-k">:</span> <span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">umode_t</span>,
    <span class="pl-smi">dir_entry</span><span class="pl-k">:</span> <span class="pl-en">Option</span>&#x3C;<span class="pl-k">&#x26;</span><span class="pl-en">ProcDirEntry</span>&#x3C;'<span class="pl-en">a</span>>>,
    <span class="pl-smi">proc_ops</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span>'<span class="pl-en">a</span> <span class="pl-en">ProcOps</span>&#x3C;'<span class="pl-en">a</span>, <span class="pl-en">T</span>>,
) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;<span class="pl-en">ProcDirEntry</span>&#x3C;'<span class="pl-en">a</span>>>
<span class="pl-k">where</span>
    <span class="pl-en">T</span><span class="pl-k">:</span> <span class="pl-en">ProcHandler</span>&#x3C;'<span class="pl-en">static</span>>,
{
<span class="pl-c">    // ProcOps contains the c-style struct, give the kernel a pointer to the address of that struct</span>
    <span class="pl-k">let</span> <span class="pl-smi">pops</span> <span class="pl-k">=</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ptr</span><span class="pl-k">::</span><span class="pl-en">addr_of!</span>(<span class="pl-smi">proc_ops</span><span class="pl-k">.</span>ops);
    <span class="pl-k">let</span> <span class="pl-smi">pde</span> <span class="pl-k">=</span> <span class="pl-k">unsafe</span> {
        <span class="pl-k">let</span> <span class="pl-smi">dir_ent</span> <span class="pl-k">=</span> <span class="pl-smi">dir_entry</span>
            <span class="pl-k">.</span><span class="pl-en">map</span>(<span class="pl-k">|</span><span class="pl-smi">de</span><span class="pl-k">|</span> <span class="pl-smi">de</span><span class="pl-k">.</span>ptr<span class="pl-k">.</span><span class="pl-en">as_ptr</span>())
            <span class="pl-k">.</span><span class="pl-en">unwrap_or_else</span>(<span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ptr</span><span class="pl-k">::</span><span class="pl-smi">null_mut</span>);
        <span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-en">proc_create</span>(
            <span class="pl-smi">name</span><span class="pl-k">.</span><span class="pl-en">as_ptr</span>() <span class="pl-k">as</span> <span class="pl-k">*const</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_char</span>,
            <span class="pl-smi">mode</span>,
            <span class="pl-smi">dir_ent</span>,
            <span class="pl-smi">pops</span>,
        )
    };
    <span class="pl-k">match</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ptr</span><span class="pl-k">::</span><span class="pl-en">NonNull</span><span class="pl-k">::</span><span class="pl-en">new</span>(<span class="pl-smi">pde</span>) {
        <span class="pl-en">None</span> <span class="pl-k">=></span> <span class="pl-en">Err</span>(<span class="pl-c1">ENOMEM</span>),
        <span class="pl-en">Some</span>(<span class="pl-smi">nn</span>) <span class="pl-k">=></span> <span class="pl-en">Ok</span>(<span class="pl-en">ProcDirEntry</span> {
            <span class="pl-smi">ptr</span><span class="pl-k">:</span> <span class="pl-smi">nn</span>,
            <span class="pl-smi">_pd</span><span class="pl-k">:</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">marker</span><span class="pl-k">::</span><span class="pl-en">PhantomData</span><span class="pl-k">::</span><span class="pl-en">default</span>(),
        }),
    }
}
</pre></div>
<hr>
<h3>Using the abstraction</h3>
<p>Now it's time to use the abstraction, it looks like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">struct</span> <span class="pl-en">ProcHand</span>;
<span class="pl-c">/// Implement `ProcHandler`, providing static references to rust-functions</span>
<span class="pl-k">...</span>
<span class="pl-k">impl</span> <span class="pl-en">ProcHandler</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">for</span> <span class="pl-en">ProcHand</span> {
  <span class="pl-k">const</span> <span class="pl-c1">OPEN</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcOpen</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span> <span class="pl-k">&#x26;|</span><span class="pl-smi">f</span><span class="pl-k">|</span> <span class="pl-k">unsafe</span> { <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">popen</span>(<span class="pl-smi">f</span>) };
  <span class="pl-k">const</span> <span class="pl-c1">READ</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcRead</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span>
    <span class="pl-k">&#x26;|</span><span class="pl-smi">f</span>, <span class="pl-smi">u</span>, <span class="pl-smi">o</span><span class="pl-k">|</span> <span class="pl-k">unsafe</span> { <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">pread</span>(<span class="pl-smi">f</span>, <span class="pl-smi">u</span>, <span class="pl-smi">o</span>) };
  <span class="pl-k">const</span> <span class="pl-c1">WRITE</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcWrite</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span>
    <span class="pl-k">&#x26;|</span><span class="pl-smi">f</span>, <span class="pl-smi">u</span>, <span class="pl-smi">o</span><span class="pl-k">|</span> <span class="pl-k">unsafe</span> { <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">pwrite</span>(<span class="pl-smi">f</span>, <span class="pl-smi">u</span>, <span class="pl-smi">o</span>) };
  <span class="pl-k">const</span> <span class="pl-c1">LSEEK</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcLseek</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span>
    <span class="pl-k">&#x26;|</span><span class="pl-smi">f</span>, <span class="pl-smi">o</span>, <span class="pl-smi">w</span><span class="pl-k">|</span> <span class="pl-k">unsafe</span> { <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">plseek</span>(<span class="pl-smi">f</span>, <span class="pl-smi">o</span>, <span class="pl-smi">w</span>) };
}
<span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">popen</span>(<span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">&#x26;mut</span> <span class="pl-en">ProcOpFileHandle</span>) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;<span class="pl-en">i32</span>> {
    <span class="pl-k">...</span>
}
<span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">pread</span>(
    <span class="pl-smi">_file</span><span class="pl-k">:</span> <span class="pl-k">&#x26;mut</span> <span class="pl-en">ProcOpFileHandle</span>,
    <span class="pl-k">mut</span> <span class="pl-smi">user_slice</span><span class="pl-k">:</span> <span class="pl-en">UserSliceWriter</span>,
    <span class="pl-smi">offset</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;(<span class="pl-en">usize</span>, <span class="pl-en">usize</span>)> {
    <span class="pl-k">...</span>
}
<span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">pwrite</span>(
    <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">&#x26;mut</span> <span class="pl-en">ProcOpFileHandle</span>,
    <span class="pl-smi">user_slice_reader</span><span class="pl-k">:</span> <span class="pl-en">UserSliceReader</span>,
    <span class="pl-smi">offset</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;(<span class="pl-en">usize</span>, <span class="pl-en">usize</span>)> {
    <span class="pl-k">...</span>
}
<span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">plseek</span>(
    <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">&#x26;mut</span> <span class="pl-en">ProcOpFileHandle</span>,
    <span class="pl-smi">offset</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
    <span class="pl-smi">whence</span><span class="pl-k">:</span> <span class="pl-en">Whence</span>,
) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;<span class="pl-smi">kernel</span><span class="pl-k">::</span><span class="pl-smi">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>> {
    <span class="pl-k">...</span>
}
</pre></div>
<hr>
<h4>User pointers</h4>
<p>Oh right, the <code>__user</code>-part.</p>
<p>On the first iterations of this module I conveniently ignored it, when the kernel is passed a buffer from a user
that is marked <code>__user</code>, it needs to copy that memory from the user to be able to use it, it can't directly read from
the provided buffer. The same goes for writing, it needs to copy memory into the buffer, it can't just directly use
the buffer.</p>
<p>On the <code>C</code>-side, this is done by the functions exposed by <code>linux/uaccess.h</code>
<a href="https://github.com/MarcusGrass/linux/blob/8e8c948133ca1a0cbf8f8add191daa739a193d99/include/linux/uaccess.h#L189">copy_from_user</a>
and <a href="https://github.com/MarcusGrass/linux/blob/8e8c948133ca1a0cbf8f8add191daa739a193d99/include/linux/uaccess.h#L201">copy_to_user</a>.</p>
<p>The functions will:</p>
<ol>
<li>Check if the operation should fault, a bit complicated and I don't fully understand where faults may be injected,
but the documentation is <a href="https://github.com/MarcusGrass/linux/blob/8e8c948133ca1a0cbf8f8add191daa739a193d99/Documentation/fault-injection/fault-injection.rst">here</a>.
<li>Check that the memory is a valid user space address
<li>Check that the object has space to be written into/read from a valid address (no OOB reads into memory the user
doesn't have access to).
<li>Do the actual copying
</ol>
<p>The <code>Rust</code> kernel code fairly conveniently wraps this into an api <a href="https://github.com/MarcusGrass/linux/blob/8e8c948133ca1a0cbf8f8add191daa739a193d99/rust/kernel/uaccess.rs">here</a>.</p>
<hr>
<p>The api is used in the wrapper for <code>PropOps</code>, it looks like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">proc_read</span>(
    <span class="pl-smi">file</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">file</span>,
    <span class="pl-smi">buf</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">ffi</span><span class="pl-k">::</span><span class="pl-smi">c_char</span>,
    <span class="pl-smi">buf_cap</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
    <span class="pl-smi">read_offset</span><span class="pl-k">:</span> <span class="pl-k">*mut</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">bindings</span><span class="pl-k">::</span><span class="pl-smi">loff_t</span>,
) <span class="pl-k">-></span> <span class="pl-en">isize</span> {
    <span class="pl-k">...</span>
    <span class="pl-k">let</span> <span class="pl-smi">buf</span> <span class="pl-k">=</span> <span class="pl-smi">buf</span> <span class="pl-k">as</span> <span class="pl-k">*mut</span> <span class="pl-en">u8</span> <span class="pl-k">as</span> <span class="pl-en">usize</span>;
    <span class="pl-k">let</span> <span class="pl-smi">buf_ref</span> <span class="pl-k">=</span> <span class="pl-en">UserSlice</span><span class="pl-k">::</span><span class="pl-en">new</span>(<span class="pl-smi">buf</span>, <span class="pl-smi">buf_cap</span>);
    <span class="pl-k">let</span> <span class="pl-smi">buf_writer</span> <span class="pl-k">=</span> <span class="pl-smi">buf_ref</span><span class="pl-k">.</span><span class="pl-en">writer</span>();
    <span class="pl-k">...</span>
    <span class="pl-k">match</span> (<span class="pl-en">T</span><span class="pl-k">::</span><span class="pl-c1">READ</span>)(<span class="pl-smi">file_ref</span>, <span class="pl-smi">buf_writer</span>, <span class="pl-smi">offset</span>) {
        <span class="pl-k">...</span>
    }
}
</pre></div>
<p>The code takes the raw <code>buf</code>-ptr which lost its <code>__user</code>-annotation through bindgen, turns it into
a raw address, and makes a <code>UserSlice</code> out of it, it then turns that slice into a <code>UserSliceWriter</code> (the user reads
data, then the kernel needs to write data), and passes that into the module's supplied <code>READ</code>-function.
Which again, has a signature that looks like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">pub</span> <span class="pl-k">type</span> <span class="pl-en">ProcRead</span>&#x3C;'<span class="pl-en">a</span>> <span class="pl-k">=</span>
<span class="pl-k">&#x26;</span>'<span class="pl-en">a</span> <span class="pl-k">dyn</span> <span class="pl-en">Fn</span>(<span class="pl-k">&#x26;mut</span> <span class="pl-en">ProcOpFileHandle</span>, <span class="pl-en">UserSliceWriter</span>, <span class="pl-smi">loff_t</span>) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;(<span class="pl-en">usize</span>, <span class="pl-en">usize</span>)>;
</pre></div>
<hr>
<h3>Writing the module</h3>
<p>The module is defined by this convenient <code>module!</code>-macro:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">struct</span> <span class="pl-en">RustProcRamFile</span>;
<span class="pl-en">module!</span> {
    <span class="pl-k">type:</span> <span class="pl-en">RustProcRamFile</span>,
    <span class="pl-smi">name</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>rust_proc_ram_file<span class="pl-pds">"</span></span>,
    <span class="pl-smi">author</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Rust for Linux Contributors<span class="pl-pds">"</span></span>,
    <span class="pl-smi">description</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Rust proc ram file example<span class="pl-pds">"</span></span>,
    <span class="pl-smi">license</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>GPL<span class="pl-pds">"</span></span>,
}
</pre></div>
<p>Most of that is metadata. But, the name will be the same name that can be <a href="https://linux.die.net/man/8/modprobe">modprobe'd</a>
to load the module, e.g. <code>modprobe rust_proc_ram_file</code>.</p>
<p>All that remains is implementing <code>kernel::Module</code> for <code>RustProcRamFile</code>, which is an arbitrary struct to represent
module data.</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">impl</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">Module</span> <span class="pl-k">for</span> <span class="pl-en">RustProcRamFile</span> {
    <span class="pl-k">fn</span> <span class="pl-en">init</span>(<span class="pl-smi">_module</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span>'<span class="pl-en">static</span> <span class="pl-en">ThisModule</span>) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;<span class="pl-c1">Self</span>> {
<span class="pl-c">        // Initialization-code</span>
        <span class="pl-k">...</span>
        <span class="pl-c1">Self</span>
    }
}
</pre></div>
<p>One hitch is that the module needs to be safe for concurrent access, it needs to be both <code>Send</code> + <code>Sync</code>.</p>
<p>Remembering that the objective is to build a <code>file</code> that is backed by just bytes (a <code>Vec&#x3C;u8></code> being most convenient),
creating a <code>RustProcRamFile(Vec&#x3C;u8>)</code> won't cut it.</p>
<p>There's a need for shared mutable state and that's where this gets tricky.</p>
<hr>
<h3>Mutex</h3>
<p>One of the simplest ways of creating (simplest by mental model at least) is by wrapping the state with a mutual-exclusion
lock, a <code>Mutex</code>.</p>
<p>Through the Kernel's <code>C</code>-API it's trivial to do that statically.</p>
<div class="highlight highlight-c"><pre><span class="pl-k">static</span> <span class="pl-en">DEFINE_MUTEX</span>(my_mutex);
</pre></div>
<p>It statically defines a mutex (<a href="https://github.com/MarcusGrass/linux/blob/8e8c948133ca1a0cbf8f8add191daa739a193d99/include/linux/mutex.h#L75">definition here</a>)
which can be interacted with, by e.g.
<a href="https://github.com/MarcusGrass/linux/blob/8e8c948133ca1a0cbf8f8add191daa739a193d99/include/linux/mutex.h#L173">mutex_lock</a>,
<a href="https://github.com/MarcusGrass/linux/blob/8e8c948133ca1a0cbf8f8add191daa739a193d99/include/linux/mutex.h#L192">mutex_unlock</a>,
etc.</p>
<p>In <code>Rust</code>-land there's a safe API for creating mutexes, it looks like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">let</span> <span class="pl-smi">pin_init_lock</span> <span class="pl-k">=</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">new_mutex!</span>(<span class="pl-en">Some</span>(<span class="pl-smi">data</span>), <span class="pl-s"><span class="pl-pds">"</span>proc_ram_mutex<span class="pl-pds">"</span></span>);
</pre></div>
<p><code>pin_init_lock</code> is something that implements <a href="https://github.com/MarcusGrass/linux/blob/8e8c948133ca1a0cbf8f8add191daa739a193d99/rust/kernel/init.rs#L838">PinInit</a>,
the most important function of which is <code>__pinned_init(self, slot: *mut T)</code><br>
which takes uninitialized memory that fits a <code>T</code> and initializes the variable there.<br>
What pinning is, why it's necessary, and how to use it properly I won't get into, people have
explained it significantly better than I ever could <a href="https://without.boats/blog/pin/">Without boats</a> for example.
For this purpose, <code>PinInit</code> could be thought of as a function looking for some memory to place its value.</p>
<p>For reasons that will become clearer later, the <code>mutex</code> will be initialized into static memory.</p>
<hr>
<p>Finally, to initialize the data that the <code>file</code> will be backed by, the code looks like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">mod</span> <span class="pl-en">backing_data</span> {
    <span class="pl-k">use</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">cell</span><span class="pl-k">::</span><span class="pl-en">UnsafeCell</span>;
    <span class="pl-k">use</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">sync</span><span class="pl-k">::</span><span class="pl-en">lock</span><span class="pl-k">::</span>{<span class="pl-en">mutex</span><span class="pl-k">::</span><span class="pl-en">MutexBackend</span>, <span class="pl-en">Lock</span>};
    <span class="pl-k">use</span> <span class="pl-c1">super</span><span class="pl-k">::*</span>;
    <span class="pl-k">static</span> <span class="pl-k">mut</span> <span class="pl-c1">MAYBE_UNINIT_DATA_SLOT</span><span class="pl-k">:</span> <span class="pl-en">MaybeUninit</span>&#x3C;<span class="pl-en">Mutex</span>&#x3C;<span class="pl-en">Option</span>&#x3C;<span class="pl-smi">alloc</span><span class="pl-k">::</span><span class="pl-smi">vec</span><span class="pl-k">::</span><span class="pl-en">Vec</span>&#x3C;<span class="pl-en">u8</span>>>>> <span class="pl-k">=</span>
        <span class="pl-en">MaybeUninit</span><span class="pl-k">::</span><span class="pl-en">uninit</span>();
    <span class="pl-k">...</span>
<span class="pl-c">    /// Initialize the backing data of this module, letting new</span>
<span class="pl-c">    /// users access it.</span>
<span class="pl-c">    /// # Safety</span>
<span class="pl-c">    /// Safe if only called once during the module's lifetime</span>
    <span class="pl-k">pub</span>(<span class="pl-c1">super</span>) <span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">init_data</span>(
        <span class="pl-smi">lock_ready</span><span class="pl-k">:</span> <span class="pl-k">impl</span> <span class="pl-en">PinInit</span>&#x3C;<span class="pl-en">Lock</span>&#x3C;<span class="pl-en">Option</span>&#x3C;<span class="pl-smi">alloc</span><span class="pl-k">::</span><span class="pl-smi">vec</span><span class="pl-k">::</span><span class="pl-en">Vec</span>&#x3C;<span class="pl-en">u8</span>>>, <span class="pl-en">MutexBackend</span>>>,
    ) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;()> {
        <span class="pl-k">unsafe</span> {
            <span class="pl-k">let</span> <span class="pl-smi">slot</span> <span class="pl-k">=</span> <span class="pl-c1">MAYBE_UNINIT_DATA_SLOT</span><span class="pl-k">.</span><span class="pl-en">as_mut_ptr</span>();
            <span class="pl-smi">lock_ready</span><span class="pl-k">.</span><span class="pl-en">__pinned_init</span>(<span class="pl-smi">slot</span>)<span class="pl-k">?</span>;
        }
        <span class="pl-en">Ok</span>(())
    }
    <span class="pl-k">...</span>
<span class="pl-c">    /// Get's the initialized data as a static reference</span>
<span class="pl-c">    /// # Safety</span>
<span class="pl-c">    /// Safe only if called after initialization, otherwise</span>
<span class="pl-c">    /// it will return a pointer to uninitialized memory.  </span>
    <span class="pl-k">pub</span>(<span class="pl-c1">super</span>) <span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">get_initialized_data</span>() <span class="pl-k">-></span> <span class="pl-k">&#x26;</span>'<span class="pl-en">static</span> <span class="pl-en">Mutex</span>&#x3C;<span class="pl-en">Option</span>&#x3C;<span class="pl-smi">alloc</span><span class="pl-k">::</span><span class="pl-smi">vec</span><span class="pl-k">::</span><span class="pl-en">Vec</span>&#x3C;<span class="pl-en">u8</span>>>> {
        <span class="pl-k">unsafe</span> { <span class="pl-c1">MAYBE_UNINIT_DATA_SLOT</span><span class="pl-k">.</span><span class="pl-en">assume_init_ref</span>() }
    }
    <span class="pl-k">...</span>
}
<span class="pl-k">impl</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">Module</span> <span class="pl-k">for</span> <span class="pl-en">RustProcRamFile</span> {
    <span class="pl-k">fn</span> <span class="pl-en">init</span>(<span class="pl-smi">_module</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span>'<span class="pl-en">static</span> <span class="pl-en">ThisModule</span>) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;<span class="pl-c1">Self</span>> {
        <span class="pl-k">...</span>
        <span class="pl-k">let</span> <span class="pl-smi">data</span> <span class="pl-k">=</span> <span class="pl-en">alloc</span><span class="pl-k">::</span><span class="pl-en">vec</span><span class="pl-k">::</span><span class="pl-en">Vec</span><span class="pl-k">::</span><span class="pl-en">new</span>();
        <span class="pl-k">let</span> <span class="pl-smi">lock</span> <span class="pl-k">=</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">new_mutex!</span>(<span class="pl-en">Some</span>(<span class="pl-smi">data</span>), <span class="pl-s"><span class="pl-pds">"</span>proc_ram_mutex<span class="pl-pds">"</span></span>);
        <span class="pl-k">unsafe</span> {
<span class="pl-c">            // Safety: Only place this is called, has to be invoked before `proc_create`</span>
            <span class="pl-en">backing_data</span><span class="pl-k">::</span><span class="pl-en">init_data</span>(<span class="pl-smi">lock</span>)<span class="pl-k">?</span>
        }
        <span class="pl-k">...</span>
    }
}
</pre></div>
<p>That's quite a lot.</p>
<hr>
<p>First off, the <code>static mut MAYBE_UNINIT_DATA_SLOT: MaybeUninit&#x3C;Mutex&#x3C;Option&#x3C;alloc::vec::Vec&#x3C;u8>>>> = MaybeUninit::uninit();</code>
creates static uninitialized memory, that's represented by the <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>.
The memory has space for a <code>Mutex</code> containing an <code>Option&#x3C;alloc::vec::Vec&#x3C;u8>></code>.<br>
Using <code>static mut</code> is heavily discouraged, some more details <a href="https://doc.rust-lang.org/rustc/lints/listing/warn-by-default.html#static-mut-refs">here</a>,
it's extremely easy to get it wrong, using it as in the above code is fine however. Messing with the <code>static mut</code> is
delegated to a submodule to encapsulate the handling more.</p>
<p>The reason for having the inner data be <code>Option</code> is to be able to remove it on module-unload and properly cleaning it up.
The <code>Drop</code>-code will show how that cleanup works in more detail, and it's likely a bit pedantic but definitively
prevents the backing data from leaking. Guaranteeing that when the module is unloaded, the data is deallocated.</p>
<hr>
<p>Second, in the module's <code>init</code>, a <code>Vec</code> is created, and put into a <code>PinInit -> Mutex</code> that needs memory for initialization.<br>
That <code>PinInit</code> is passed to <code>init_data</code> which takes a pointer to the static memory <code>MAYBE_UNINIT_DATA_SLOT</code> and writes
the mutex into it.</p>
<p>Now There's an initialized <code>Mutex</code>.</p>
<hr>
<h3>Storing the ProcDirEntry</h3>
<p>Now <code>proc_create</code> can be called which will create a <code>proc</code>-file.</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">mod</span> <span class="pl-en">backing_data</span> {
    <span class="pl-k">...</span>
    <span class="pl-k">struct</span> <span class="pl-en">SingleAccessPdeStore</span>(<span class="pl-en">UnsafeCell</span>&#x3C;<span class="pl-en">Option</span>&#x3C;<span class="pl-en">ProcDirEntry</span>&#x3C;'<span class="pl-en">static</span>>>>);
    <span class="pl-k">unsafe</span> <span class="pl-k">impl</span> <span class="pl-en">Sync</span> <span class="pl-k">for</span> <span class="pl-en">SingleAccessPdeStore</span> {}
    <span class="pl-k">static</span> <span class="pl-c1">ENTRY</span><span class="pl-k">:</span> <span class="pl-en">SingleAccessPdeStore</span> <span class="pl-k">=</span> <span class="pl-en">SingleAccessPdeStore</span>(<span class="pl-en">UnsafeCell</span><span class="pl-k">::</span><span class="pl-en">new</span>(<span class="pl-en">None</span>));
    <span class="pl-k">...</span>
<span class="pl-c">    /// Write PDE into static memory</span>
<span class="pl-c">    /// # Safety</span>
<span class="pl-c">    /// Any concurrent access is unsafe.  </span>
    <span class="pl-k">pub</span>(<span class="pl-c1">super</span>) <span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">set_pde</span>(<span class="pl-smi">pde</span><span class="pl-k">:</span> <span class="pl-en">ProcDirEntry</span>&#x3C;'<span class="pl-en">static</span>>) {
        <span class="pl-k">unsafe</span> {
            <span class="pl-c1">ENTRY</span><span class="pl-k">.</span><span class="pl-c1">0.</span><span class="pl-en">get</span>()<span class="pl-k">.</span><span class="pl-en">write</span>(<span class="pl-en">Some</span>(<span class="pl-smi">pde</span>));
        }
    }
<span class="pl-c">    /// Remove the PDE</span>
<span class="pl-c">    /// # Safety</span>
<span class="pl-c">    /// While safe to invoke regardless of PDE initialization,</span>
<span class="pl-c">    /// any concurrent access is unsafe.  </span>
    <span class="pl-k">pub</span>(<span class="pl-c1">super</span>) <span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">take_pde</span>() <span class="pl-k">-></span> <span class="pl-en">Option</span>&#x3C;<span class="pl-en">ProcDirEntry</span>&#x3C;'<span class="pl-en">static</span>>> {
        <span class="pl-k">unsafe</span> {
            <span class="pl-k">let</span> <span class="pl-smi">mut_ref</span> <span class="pl-k">=</span> <span class="pl-c1">ENTRY</span><span class="pl-k">.</span><span class="pl-c1">0.</span><span class="pl-en">get</span>()<span class="pl-k">.</span><span class="pl-en">as_mut</span>()<span class="pl-k">?</span>;
            <span class="pl-smi">mut_ref</span><span class="pl-k">.</span><span class="pl-en">take</span>()
        }
    }
}
<span class="pl-k">fn</span> <span class="pl-en">init</span>(<span class="pl-smi">_module</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span>'<span class="pl-en">static</span> <span class="pl-en">ThisModule</span>) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;<span class="pl-c1">Self</span>> {
        <span class="pl-k">const</span> <span class="pl-c1">POPS</span><span class="pl-k">:</span> <span class="pl-en">ProcOps</span>&#x3C;'<span class="pl-en">static</span>, <span class="pl-en">ProcHand</span>> <span class="pl-k">=</span> <span class="pl-en">ProcOps</span><span class="pl-k">::</span>&#x3C;'<span class="pl-en">static</span>, <span class="pl-en">ProcHand</span>><span class="pl-k">::</span><span class="pl-en">new</span>(<span class="pl-c1">0</span>);
<span class="pl-c">        // Struct defined inline since this is the only safe place for it to be used</span>
        <span class="pl-k">struct</span> <span class="pl-en">ProcHand</span>;
        <span class="pl-k">impl</span> <span class="pl-en">ProcHand</span> {
            <span class="pl-k">...</span>
        }
        <span class="pl-k">let</span> <span class="pl-smi">data</span> <span class="pl-k">=</span> <span class="pl-en">alloc</span><span class="pl-k">::</span><span class="pl-en">vec</span><span class="pl-k">::</span><span class="pl-en">Vec</span><span class="pl-k">::</span><span class="pl-en">new</span>();
        <span class="pl-k">let</span> <span class="pl-smi">lock</span> <span class="pl-k">=</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">new_mutex!</span>(<span class="pl-en">Some</span>(<span class="pl-smi">data</span>), <span class="pl-s"><span class="pl-pds">"</span>proc_ram_mutex<span class="pl-pds">"</span></span>);
        <span class="pl-k">unsafe</span> {
<span class="pl-c">            // Safety: Only place this is called, has to be invoked before `proc_create`</span>
            <span class="pl-en">backing_data</span><span class="pl-k">::</span><span class="pl-en">init_data</span>(<span class="pl-smi">lock</span>)<span class="pl-k">?</span>
        }
<span class="pl-c">        // This is technically unsound, e.g. READ is not safe to invoke until</span>
<span class="pl-c">        // `init_data` has been called, but could theoretically be invoked in a safe context before</span>
<span class="pl-c">        // then, so don't, it's ordered like this for a reason.</span>
        <span class="pl-k">impl</span> <span class="pl-en">ProcHandler</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">for</span> <span class="pl-en">ProcHand</span> {
            <span class="pl-k">const</span> <span class="pl-c1">OPEN</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcOpen</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span> <span class="pl-k">&#x26;|</span><span class="pl-smi">f</span><span class="pl-k">|</span> <span class="pl-k">unsafe</span> { <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">popen</span>(<span class="pl-smi">f</span>) };
            <span class="pl-k">const</span> <span class="pl-c1">READ</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcRead</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span>
                <span class="pl-k">&#x26;|</span><span class="pl-smi">f</span>, <span class="pl-smi">u</span>, <span class="pl-smi">o</span><span class="pl-k">|</span> <span class="pl-k">unsafe</span> { <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">pread</span>(<span class="pl-smi">f</span>, <span class="pl-smi">u</span>, <span class="pl-smi">o</span>) };
            <span class="pl-k">const</span> <span class="pl-c1">WRITE</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcWrite</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span>
                <span class="pl-k">&#x26;|</span><span class="pl-smi">f</span>, <span class="pl-smi">u</span>, <span class="pl-smi">o</span><span class="pl-k">|</span> <span class="pl-k">unsafe</span> { <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">pwrite</span>(<span class="pl-smi">f</span>, <span class="pl-smi">u</span>, <span class="pl-smi">o</span>) };
            <span class="pl-k">const</span> <span class="pl-c1">LSEEK</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcLseek</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span>
                <span class="pl-k">&#x26;|</span><span class="pl-smi">f</span>, <span class="pl-smi">o</span>, <span class="pl-smi">w</span><span class="pl-k">|</span> <span class="pl-k">unsafe</span> { <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">plseek</span>(<span class="pl-smi">f</span>, <span class="pl-smi">o</span>, <span class="pl-smi">w</span>) };
        }
        <span class="pl-k">let</span> <span class="pl-smi">pde</span> <span class="pl-k">=</span> <span class="pl-en">proc_create</span>(<span class="pl-en">c_str!</span>(<span class="pl-s"><span class="pl-pds">"</span>rust-proc-file<span class="pl-pds">"</span></span>), <span class="pl-c1">0666</span>, <span class="pl-en">None</span>, <span class="pl-k">&#x26;</span><span class="pl-c1">POPS</span>)<span class="pl-k">?</span>;
        <span class="pl-k">unsafe</span> {
<span class="pl-c">            // Safety: Only place this is called, no concurrent access</span>
            <span class="pl-en">backing_data</span><span class="pl-k">::</span><span class="pl-en">set_pde</span>(<span class="pl-smi">pde</span>);
        }
        <span class="pl-en">pr_info!</span>(<span class="pl-s"><span class="pl-pds">"</span>Loaded /proc/rust-proc-file<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
        <span class="pl-en">Ok</span>(<span class="pl-c1">Self</span>)
    }
</pre></div>
<p>That's also quite a lot.
Now the code is encountering issues with unsoundness (an API that is not marked as unsafe but is unsafe under some conditions).</p>
<hr>
<p>Starting from the top:</p>
<p>Calling <code>proc_create</code> returns a <code>ProcDirEntry</code> which when dropped removes the <code>proc</code>-file. The entry should be kept alive
until the module is dropped. Therefore, a static variable <code>ENTRY</code> is created to house it, it will get removed on
the module's <code>Drop</code>.</p>
<p><code>static</code>-entries need to be <a href="https://doc.rust-lang.org/std/marker/trait.Sync.html">Sync</a> i.e. it can be shared between threads,
<code>UnsafeCell</code> is not <code>Sync</code>, it therefore needs to be wrapped in the <a href="https://doc.rust-lang.org/rust-by-example/generics/new_types.html">newtype</a>
<code>SingleAccessPdeStore</code>. It is indeed safe to be shared between threads in some conditions, so
<code>Sync</code> is unsafely implemented through:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">unsafe</span> <span class="pl-k">impl</span> <span class="pl-en">Sync</span> <span class="pl-k">for</span> <span class="pl-en">SingleAccessPdeStore</span> {}
</pre></div>
<p>It tells the compiler that even though it doesn't look <code>Sync</code> it should treat is as <code>Sync</code>.
(<code>Sync</code> and <code>Send</code> are examples of automatic trait implementations, if a <code>struct</code> contain types that all implement
<code>Send</code> and/or <code>Sync</code>, that struct will also implement <code>Send</code> or <code>Sync</code>, a bit more on that <a href="https://doc.rust-lang.org/stable/unstable-book/language-features/auto-traits.html">here</a>).</p>
<hr>
<p>Next comes two <code>unsafe</code> functions. One sets the <code>ENTRY</code> to a provided <code>ProcDirEntry&#x3C;'static></code>,
the operation is safe as long as it doesn't happen concurrently, that would create a data-race.</p>
<p>The other takes the <code>ProcDirEntry</code> from <code>ENTRY</code>, this is done on module teardown, when the module is unloaded, for example
through <a href="https://linux.die.net/man/8/rmmod">rmmod</a>, <code>rmmod rust_proc_ram_file</code>.</p>
<p>Entering the <code>init</code>-function, there are struct definitions and trait-implementations defined inside the function.<br>
The reasons for this is to make some inherent <code>unsoundness</code> about the memory-lifecycle less dangerous, it's worth getting
into why that it is, and what the trade-offs of having some <code>unsoundness</code> is.</p>
<hr>
<h3>Memory lifecycle, you, me, and <code>C</code></h3>
<p>Again, the C-api looks like this:</p>
<div class="highlight highlight-c"><pre><span class="pl-k">struct</span> proc_ops {
	<span class="pl-k">unsigned</span> <span class="pl-k">int</span> proc_flags;
	<span class="pl-c1">int</span>	(*proc_open)(<span class="pl-k">struct</span> inode *, <span class="pl-k">struct</span> file *);
	<span class="pl-c1">ssize_t</span>	(*proc_read)(<span class="pl-k">struct</span> file *, <span class="pl-k">char</span> __user *, <span class="pl-c1">size_t</span>, <span class="pl-c1">loff_t</span> *);
	<span class="pl-c1">ssize_t</span> (*proc_read_iter)(<span class="pl-k">struct</span> kiocb *, <span class="pl-k">struct</span> iov_iter *);
	<span class="pl-c1">ssize_t</span>	(*proc_write)(<span class="pl-k">struct</span> file *, <span class="pl-k">const</span> <span class="pl-k">char</span> __user *, <span class="pl-c1">size_t</span>, <span class="pl-c1">loff_t</span> *);
	<span class="pl-c">/* mandatory unless nonseekable_open() or equivalent is used */</span>
	<span class="pl-c1">loff_t</span>	(*proc_lseek)(<span class="pl-k">struct</span> file *, <span class="pl-c1">loff_t</span>, <span class="pl-k">int</span>);
	<span class="pl-c1">int</span>	(*proc_release)(<span class="pl-k">struct</span> inode *, <span class="pl-k">struct</span> file *);
	<span class="pl-c1">__poll_t</span> (*proc_poll)(<span class="pl-k">struct</span> file *, <span class="pl-k">struct</span> poll_table_struct *);
	<span class="pl-c1">long</span>	(*proc_ioctl)(<span class="pl-k">struct</span> file *, <span class="pl-k">unsigned</span> <span class="pl-k">int</span>, <span class="pl-k">unsigned</span> <span class="pl-k">long</span>);
#<span class="pl-k">ifdef</span> CONFIG_COMPAT
	<span class="pl-c1">long</span>	(*proc_compat_ioctl)(<span class="pl-k">struct</span> file *, <span class="pl-k">unsigned</span> <span class="pl-k">int</span>, <span class="pl-k">unsigned</span> <span class="pl-k">long</span>);
#<span class="pl-k">endif</span>
	<span class="pl-c1">int</span>	(*proc_mmap)(<span class="pl-k">struct</span> file *, <span class="pl-k">struct</span> vm_area_struct *);
	<span class="pl-k">unsigned</span> <span class="pl-smi">long</span> (*proc_get_unmapped_area)(<span class="pl-k">struct</span> file *, <span class="pl-k">unsigned</span> <span class="pl-k">long</span>, <span class="pl-k">unsigned</span> <span class="pl-k">long</span>, <span class="pl-k">unsigned</span> <span class="pl-k">long</span>, <span class="pl-k">unsigned</span> <span class="pl-k">long</span>);
} __randomize_layout;
<span class="pl-k">struct</span> proc_dir_entry *<span class="pl-en">proc_create</span>(<span class="pl-k">const</span> <span class="pl-k">char</span> *name, <span class="pl-c1">umode_t</span> mode, <span class="pl-k">struct</span> proc_dir_entry *parent, <span class="pl-k">const</span> <span class="pl-k">struct</span> proc_ops *proc_ops);
</pre></div>
<p>The module needs to call the function <code>proc_create</code> supplying a pointer <code>const struct proc_ops *proc_ops</code>
which itself contains function pointers. What are the lifetime requirements?</p>
<hr>
<p><code>const struct proc_ops *proc_ops</code> has a requirement to live until <code>proc_remove</code> is called on the returned <code>proc_dir_entry*</code>,
that's easily represented in <code>Rust</code>, we could model the API to accept something with the lifetime <code>'a</code> and return
a <code>ProcDirEntry&#x3C;'a></code>, taking ownership of the reference to <code>ProcOps</code> and calling <code>proc_remove</code> in the destructor.</p>
<p>But how long do the function pointers that are themselves contained in <code>proc_ops</code> need to live?</p>
<p>On could assume it's the same, <code>'a</code>, but let's consider how the kernel 'routes' a user through the module and the
lifecycle of an interaction.</p>
<hr>
<h4>A user interaction</h4>
<p>A user wants to open the file, by name.</p>
<ol>
<li>The user issues the <a href="https://man7.org/linux/man-pages/man2/open.2.html">open</a> syscall.
<li>The kernel picks up the open syscall, and finds this <code>*proc_dir_entry</code>.
<li>The kernel enters the <code>proc_open</code>-function.
<li>The kernel sets the correct register return address value.
<li>The kernel yields execution.
</ol>
<hr>
<p>The kernel handles two pointers from the module, non-atomically, in separate steps, multiple users could trigger
this interaction concurrently (the reason for the lock).</p>
<p>In the case that there exists a <code>*proc_dir_entry</code> but the <code>proc_open</code>-function pointer is
<a href="https://en.wikipedia.org/wiki/Dangling_pointer">dangling</a>,
because the lifetime of it is less than <code>*proc_dir_entry</code>, or they have the same lifetime but the mechanics of
the free happens in an unfavourable order. In that case, the kernel will try to access a dangling pointer,
which may or may not cause chaos. A dangling pointer is worse than a null-pointer in this case, since a
null-pointer is often acceptable for <code>*proc_ops</code>-functions.</p>
<hr>
<p>In another case, the <code>proc_dir_entry</code> may definitively be removed first, but since some process may have read the
function pointer <code>proc_open</code> from it, but not started executing it (race) yet, <code>proc_open</code> can theoretically
never be safely destroyed. The reason for that is because in a <a href="https://en.wikipedia.org/wiki/Time-sharing">time-sharing OS</a>
no guarantees are made about the timeliness of operations. Therefore, the lifetime requirement of
<code>proc_open</code> is <code>'static</code> as represented by:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">...</span>
<span class="pl-k">const</span> <span class="pl-c1">OPEN</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcOpen</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span> <span class="pl-k">&#x26;</span><span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-smi">popen</span>;
<span class="pl-k">...</span>
</pre></div>
<hr>
<h4>Constraints caused by <code>'static</code>-lifetimes</h4>
<p>Static (sloppily expressed) means 'for the duration of the program', if there's a <code>'static</code>-requirement for a variable
it means that that variable needs its memory to be allocated in the binary.</p>
<p>An example would be a string literal</p>
<div class="highlight highlight-rust"><pre><span class="pl-c">// The `'static` lifetime can be elided</span>
<span class="pl-k">const</span> <span class="pl-c1">MY_STR</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span>'<span class="pl-en">static</span> <span class="pl-en">str</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>;
<span class="pl-c">// Implicitly also `'static`</span>
<span class="pl-k">static</span> <span class="pl-c1">MY_STR2</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span> <span class="pl-en">str</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>;
<span class="pl-c">// or </span>
<span class="pl-k">fn</span> <span class="pl-en">my_fn</span>() {
    <span class="pl-k">let</span> <span class="pl-smi">my_str</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>;
}
</pre></div>
<hr>
<p>In all cases the string-literal exists in the binary, the difference between these cases are that in the
case of the <code>const</code>-variable some space is allocated in the binary that fits a reference to a <code>str</code>,
which may point to some data that exist in the <code>data</code>-section of the binary (or somewhere else, implementation dependent).<br>
<code>const</code> also dictates that this value may never change.</p>
<p><code>static</code> also makes sure that the binary has space for the variable (still a reference to a string), it will also
point to some data that is likely to be in the <code>data</code>-section, but it is theoretically legal to change the data that
it's pointing to (with some constraints).</p>
<p>In the function, space is made available on the stack for the reference, but the actual <code>hello</code> is likely again in
the <code>data</code>-section.</p>
<hr>
<h4>Using static data for the backing storage</h4>
<p>Looking back at the purpose of the module, data needs to be stored with a static lifetime, there are multiple ways
to achieve this in <code>Rust</code>, the data can be owned directly, like a member of the module <code>RustProcRamFile</code>.
However, this means that when the module is dropped, the data is dropped as well. Since the function-pointers
have a <code>'static</code>-requirement that doesn't work.</p>
<p>Even if the data is wrapped in a <code>Box</code>, or an <code>Arc</code>, the <code>RustProcRamFile</code>-module can't own it for the above reason,
the functions needs to live for the duration of the program (and be valid), a global static is necessary (sigh).</p>
<p>But, the killer that makes it impossible to make the state a part of <code>RustProcRamFile</code> is that
the function-pointers that are exposed cannot capture state, if the state is a part of <code>RustProcRamFile</code>, to access
it through a function, the signature would have to be:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">popen</span>(<span class="pl-k">&#x26;</span><span class="pl-c1">self</span>, <span class="pl-k">...</span>) <span class="pl-k">...</span> {
    <span class="pl-k">...</span>
}
</pre></div>
<p>Which cannot be made to fit the required function signature of the <code>C</code>-api.</p>
<p>Here is where the globals come in:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">...</span>
<span class="pl-k">static</span> <span class="pl-k">mut</span> <span class="pl-c1">MAYBE_UNINIT_DATA_SLOT</span><span class="pl-k">:</span> <span class="pl-en">MaybeUninit</span>&#x3C;<span class="pl-en">Mutex</span>&#x3C;<span class="pl-en">Option</span>&#x3C;<span class="pl-smi">alloc</span><span class="pl-k">::</span><span class="pl-smi">vec</span><span class="pl-k">::</span><span class="pl-en">Vec</span>&#x3C;<span class="pl-en">u8</span>>>>> <span class="pl-k">=</span>
        <span class="pl-en">MaybeUninit</span><span class="pl-k">::</span><span class="pl-en">uninit</span>();
<span class="pl-k">...</span>
<span class="pl-k">static</span> <span class="pl-c1">ENTRY</span><span class="pl-k">:</span> <span class="pl-en">SingleAccessPdeStore</span> <span class="pl-k">=</span> <span class="pl-en">SingleAccessPdeStore</span>(<span class="pl-en">UnsafeCell</span><span class="pl-k">::</span><span class="pl-en">new</span>(<span class="pl-en">None</span>));
<span class="pl-k">...</span>
<span class="pl-k">const</span> <span class="pl-c1">POPS</span><span class="pl-k">:</span> <span class="pl-en">ProcOps</span>&#x3C;'<span class="pl-en">static</span>, <span class="pl-en">ProcHand</span>> <span class="pl-k">=</span> <span class="pl-en">ProcOps</span><span class="pl-k">::</span>&#x3C;'<span class="pl-en">static</span>, <span class="pl-en">ProcHand</span>><span class="pl-k">::</span><span class="pl-en">new</span>(<span class="pl-c1">0</span>);
</pre></div>
<hr>
<p>Looking at the definitions, two of these contain data that can (and will) be changed, those are therefore <code>static</code>,
one (the container of the functions that are passed through the <code>C</code>-api) is marked as <code>const</code>, since it will never change.</p>
<p><code>MAYBE_UNINIT_DATA_SLOT</code> is MaybeUninit, when the program starts, there is already space made available in
the binary for the data it will contain, on module-initialization data will be written into that space.</p>
<p>Same goes for <code>Entry</code>, <code>UnsafeCell</code> does essentially the same thing, there's a reason that both aren't wrapped by
<code>UnsafeCell&#x3C;Option></code>, partially performance.</p>
<h4>MaybeUninit vs UnsafeCell&#x3C;Option></h4>
<p><a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a> contains potentially uninitialized data.
Accessing that data, by for example creating a reference to it, is UB if that data is not yet initialized.<br>
Which means that the requirements for safe-access is only possible if:</p>
<ol>
<li>Non-modifying access happens after initialization.
<li>Modifying access happens in a non-concurrent context.
</ol>
<hr>
<p><a href="https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html">UnsafeCell&#x3C;Option></a> does not contain potentially
uninitialized data, the uninitialized state is represented by the <code>Option</code>.
Safe access only requires that there is no concurrent access (of any kind) at the same time as mutable access.
It's a bit easier to make safe.</p>
<p>I would prefer <code>UnsafeCell&#x3C;Option&#x3C;T>></code> in both cases, but as the <code>PinInit</code>-api is constructed (that is needed for
the <code>Mutex</code>), a slot of type <code>T</code> (being the <code>Mutex</code>) needs to be provided. Therefore, it would have to be
<code>static UnsafeCell&#x3C;Lock&#x3C;..>></code> which cannot be instantiated at compile-time in the same way that an <code>UnsafeCell&#x3C;Option&#x3C;T>></code>
can (<code>static MY_VAR: UnsafeCell&#x3C;Option&#x3C;String>> = UnsafeCell::new(None)</code> for example).</p>
<p>One could make it work anyway, by some wrangling and implementation using <code>PinInit</code> but for this project I decided
not to.</p>
<h4>Global POPS and an unsound API</h4>
<p>Back again to POPS, the <code>init</code>-function and unsoundness:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">init</span>(<span class="pl-smi">_module</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span>'<span class="pl-en">static</span> <span class="pl-en">ThisModule</span>) <span class="pl-k">-></span> <span class="pl-en">Result</span>&#x3C;<span class="pl-c1">Self</span>> {
        <span class="pl-k">const</span> <span class="pl-c1">POPS</span><span class="pl-k">:</span> <span class="pl-en">ProcOps</span>&#x3C;'<span class="pl-en">static</span>, <span class="pl-en">ProcHand</span>> <span class="pl-k">=</span> <span class="pl-en">ProcOps</span><span class="pl-k">::</span>&#x3C;'<span class="pl-en">static</span>, <span class="pl-en">ProcHand</span>><span class="pl-k">::</span><span class="pl-en">new</span>(<span class="pl-c1">0</span>);
<span class="pl-c">        // Struct defined inline since this is the only safe place for it to be used</span>
        <span class="pl-k">struct</span> <span class="pl-en">ProcHand</span>;
        <span class="pl-k">impl</span> <span class="pl-en">ProcHand</span> {
            <span class="pl-k">...</span>
        }
        <span class="pl-k">let</span> <span class="pl-smi">data</span> <span class="pl-k">=</span> <span class="pl-en">alloc</span><span class="pl-k">::</span><span class="pl-en">vec</span><span class="pl-k">::</span><span class="pl-en">Vec</span><span class="pl-k">::</span><span class="pl-en">new</span>();
        <span class="pl-k">let</span> <span class="pl-smi">lock</span> <span class="pl-k">=</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">new_mutex!</span>(<span class="pl-en">Some</span>(<span class="pl-smi">data</span>), <span class="pl-s"><span class="pl-pds">"</span>proc_ram_mutex<span class="pl-pds">"</span></span>);
        <span class="pl-k">unsafe</span> {
<span class="pl-c">            // Safety: Only place this is called, has to be invoked before `proc_create`</span>
            <span class="pl-en">backing_data</span><span class="pl-k">::</span><span class="pl-en">init_data</span>(<span class="pl-smi">lock</span>)<span class="pl-k">?</span>
        }
<span class="pl-c">        // This is technically unsound, e.g. READ is not safe to invoke until</span>
<span class="pl-c">        // `init_data` has been called, but could theoretically be invoked in a safe context before</span>
<span class="pl-c">        // then, so don't, it's ordered like this for a reason.</span>
        <span class="pl-k">impl</span> <span class="pl-en">ProcHandler</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">for</span> <span class="pl-en">ProcHand</span> {
            <span class="pl-k">const</span> <span class="pl-c1">OPEN</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcOpen</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span> <span class="pl-k">&#x26;|</span><span class="pl-smi">f</span><span class="pl-k">|</span> <span class="pl-k">unsafe</span> { <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">popen</span>(<span class="pl-smi">f</span>) };
            <span class="pl-k">const</span> <span class="pl-c1">READ</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcRead</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span>
                <span class="pl-k">&#x26;|</span><span class="pl-smi">f</span>, <span class="pl-smi">u</span>, <span class="pl-smi">o</span><span class="pl-k">|</span> <span class="pl-k">unsafe</span> { <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">pread</span>(<span class="pl-smi">f</span>, <span class="pl-smi">u</span>, <span class="pl-smi">o</span>) };
            <span class="pl-k">const</span> <span class="pl-c1">WRITE</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcWrite</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span>
                <span class="pl-k">&#x26;|</span><span class="pl-smi">f</span>, <span class="pl-smi">u</span>, <span class="pl-smi">o</span><span class="pl-k">|</span> <span class="pl-k">unsafe</span> { <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">pwrite</span>(<span class="pl-smi">f</span>, <span class="pl-smi">u</span>, <span class="pl-smi">o</span>) };
            <span class="pl-k">const</span> <span class="pl-c1">LSEEK</span><span class="pl-k">:</span> <span class="pl-en">kernel</span><span class="pl-k">::</span><span class="pl-en">proc_fs</span><span class="pl-k">::</span><span class="pl-en">ProcLseek</span>&#x3C;'<span class="pl-en">static</span>> <span class="pl-k">=</span>
                <span class="pl-k">&#x26;|</span><span class="pl-smi">f</span>, <span class="pl-smi">o</span>, <span class="pl-smi">w</span><span class="pl-k">|</span> <span class="pl-k">unsafe</span> { <span class="pl-c1">Self</span><span class="pl-k">::</span><span class="pl-en">plseek</span>(<span class="pl-smi">f</span>, <span class="pl-smi">o</span>, <span class="pl-smi">w</span>) };
        }
        <span class="pl-k">let</span> <span class="pl-smi">pde</span> <span class="pl-k">=</span> <span class="pl-en">proc_create</span>(<span class="pl-en">c_str!</span>(<span class="pl-s"><span class="pl-pds">"</span>rust-proc-file<span class="pl-pds">"</span></span>), <span class="pl-c1">0666</span>, <span class="pl-en">None</span>, <span class="pl-k">&#x26;</span><span class="pl-c1">POPS</span>)<span class="pl-k">?</span>;
        <span class="pl-k">unsafe</span> {
<span class="pl-c">            // Safety: Only place this is called, no concurrent access</span>
            <span class="pl-en">backing_data</span><span class="pl-k">::</span><span class="pl-en">set_pde</span>(<span class="pl-smi">pde</span>);
        }
        <span class="pl-en">pr_info!</span>(<span class="pl-s"><span class="pl-pds">"</span>Loaded /proc/rust-proc-file<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>);
        <span class="pl-en">Ok</span>(<span class="pl-c1">Self</span>)
    }
</pre></div>
<p><code>ProcHand::pread, ProcHand::pwrite, and ProcHand::plseek</code> all access data that is not safe to
access any time before initialization, but safe to access after, therefore they are marked as unsafe.</p>
<p>However, since the API (that I wrote...) takes a safe-function, they are wrapped by a <code>'static</code> closure that
is safe, then uses an <code>unsafe</code>-block internally.</p>
<p>This wrapping is implemented AFTER the code that initializes the data that is safe to access after initialization.
However, the API is still <code>unsound</code>, since the function could theoretically be called before that initialization,
even though it's defined after it.</p>
<p>One note on the wrapping, running it through <a href="https://godbolt.org/z/qrTW5PTW8">godbolt</a> again shows it's still being inlined.</p>
<p>This problem can be worked around, by for example, creating a <code>static INITIALIZED: AtomicBool = AtomicBool::new(false);</code>,
and then setting that during initialization. But that requires an atomic-read on each access for something that
is set once on initialization. This is a tradeoff of soundness vs performance, in this case performance is chosen,
because the plan for this code is not to be distributed to someone else's production environment,
or having to be maintained by someone else. In that case opting for soundness may be preferable, although the
'window' for creating UB here is quite slim.</p>
<h4>Deallocation</h4>
<p>Finally, the data is set up, and can be used with some constraints, now the teardown.</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">impl</span> <span class="pl-en">Drop</span> <span class="pl-k">for</span> <span class="pl-en">RustProcRamFile</span> {
    <span class="pl-k">fn</span> <span class="pl-en">drop</span>(<span class="pl-k">&#x26;mut</span> <span class="pl-c1">self</span>) {
<span class="pl-c">        // Remove the PDE if initialized</span>
<span class="pl-c">        // Drop it to remove the proc entry</span>
        <span class="pl-k">unsafe</span> {
<span class="pl-c">            // Safety:</span>
<span class="pl-c">            // Runs at most once, no concurrent access</span>
            <span class="pl-en">backing_data</span><span class="pl-k">::</span><span class="pl-en">take_pde</span>();
        }
<span class="pl-c">        // Remove and deallocate the data</span>
        <span class="pl-k">unsafe</span> {
<span class="pl-c">            // Safety:</span>
<span class="pl-c">            // This module is only instantiated if data is initialized, therefore</span>
<span class="pl-c">            // the data is initialized when this destructor is run.</span>
            <span class="pl-en">backing_data</span><span class="pl-k">::</span><span class="pl-en">get_initialized_data</span>()<span class="pl-k">.</span><span class="pl-en">lock</span>()<span class="pl-k">.</span><span class="pl-en">take</span>();
        }
<span class="pl-c">        // There is theoretically a race-condition, where module-users are currently in a</span>
<span class="pl-c">        // proc handler, the handler itself is 'static, so the kernel will be trusted</span>
<span class="pl-c">        // to keep function-related memory initialized until it's no longer needed.</span>
<span class="pl-c">        // There is a race-condition where it's impossible that the file can be removed, and it's made sure that all users</span>
<span class="pl-c">        // get a 'graceful' exit, i.e. all users who can see a file and start a proc-op gets to</span>
<span class="pl-c">        // finish it. This is because the module recording that a user has entered, and removing</span>
<span class="pl-c">        // the proc-entry can't happen atomically together. It's impossible to ensure that there</span>
<span class="pl-c">        // isn't a gap between a user entering the proc-handler, then recording its presence, and</span>
<span class="pl-c">        // removing the proc-entry and checking if the user registered.</span>
<span class="pl-c">        // In that case, the user will get an EBUSY</span>
    }
}
</pre></div>
<p>First, the <code>ProcDirEntry</code> is dropped, invoking the kernel's <code>proc_remove</code> removing the proc-file.<br>
After that, a reference to the initialized data is taken, and the mutex is accessed to remove the backing-data for the
'file'. When that data is dropped, the backing data will be deallocated.
With that, all runtime-created data is removed, the only thing that may remain are function pointers which were static
anyway, and accessing them will produce a safe error.</p>
<h2>Testing</h2>
<p>Now that the module is 'complete', how can it be tested, and what is needed for testing?</p>
<h3>Objective retrospective</h3>
<p>The objective was to write a <code>proc</code>-file that functions as a regular <code>file</code> with memory in <code>RAM</code>.<br>
It should handle <code>open</code>, <code>read</code>, <code>write</code>, and <code>lseek</code>.</p>
<h3>Implementing tests</h3>
<p>A simple way of testing is to <code>modprobe rust_proc_ram_file &#x26;&#x26; cat /proc/rust-proc-file</code>.
See that nothing is there.</p>
<p>Then <code>echo "abcd" > /proc/rust-proc-file &#x26;&#x26; cat /proc/rust-proc-file</code> and
see that <code>abcd</code> is displayed in the terminal.</p>
<p>Then <code>echo "defg" > /proc/rust-proc-file &#x26;&#x26; cat /proc/rust-proc-file</code> and
see that only <code>defg</code> is displayed in the terminal.</p>
<p>Then <code>echo "abcd" >> /proc/rust-proc-file &#x26;&#x26; cat /proc/rust-proc-file</code> and
see that <code>defg\nabcd</code> is displayed in the terminal.</p>
<p>That's a simple test to cover very basic <code>open</code>, <code>read</code>, and <code>write</code> functionality,
but no concurrency or <code>seeking</code>.</p>
<p>I wrote this small tester that will:</p>
<ol>
<li>Check opening the file with different open-options (like <code>trucate</code> truncates the file).
<li>Check reading and writing.
<li>Check writing, seeking, and reading.
<li>Check writing, seeking, and overwriting.
<li>Check writing concurrently, and then reading.
<li>Check writing concurrently while the module is unloaded/reloaded.
</ol>
<p>If this was a serious module that should be shipped to users, then further testing
of edge-conditions, weird user inputs, and fuzzing would be appropriate, but
for a simple demo-module that will have to be enough.</p>
<h2>Summing up</h2>
<p>All important parts are now covered, the actual implementation of <code>pread</code>, <code>pwrite</code>, <code>plseek</code>, is fairly boring
and straight-forward, the full code can be found <a href="https://github.com/MarcusGrass/linux/tree/8e8c948133ca1a0cbf8f8add191daa739a193d99">here</a>
if that, and the rest of the implementation is interesting.</p>
<h3>Generating bindings</h3>
<p>First off bindings for the Linux <code>C</code>-API for creating a <code>proc-file</code> had to be generated, it only required adding
a header in the list <a href="https://github.com/MarcusGrass/linux/blob/8e8c948133ca1a0cbf8f8add191daa739a193d99/rust/bindings/bindings_helper.h#L19">here</a></p>
<h3>Wrapping the API with reasonable lifetimes</h3>
<p>The <code>C</code>-API has some lifetime requirements, those are encoded in the <a href="https://github.com/MarcusGrass/linux/blob/8e8c948133ca1a0cbf8f8add191daa739a193d99/rust/kernel/proc_fs.rs">proc_fs.rs</a>.</p>
<p>The <code>C</code>-API-parts that take function-pointers can be wrapped by a <code>Rust</code>-fn with zero-cost (<a href="https://godbolt.org/z/qrTW5PTW8">as was show here</a>), allowing a more <code>Rust</code>-y API
to be exposed.</p>
<h3>Dealing with static data in a concurrent context</h3>
<p>Some static data needs to be initialized at runtime but not concurrently mutably accessed, that was represented by a <code>MaybeUninit</code>.</p>
<p>Some static data does not need to be initialized at runtime, but cannot be mutable access concurrently, that was
represented by an <code>UnsafeCell&#x3C;Option&#x3C;T>></code>.</p>
<p>Some static data was also constant, never mutable, and safe for all non-mutable access, that was represented by a
regular <code>const &#x3C;VAR></code>.</p>
<h3>Tradeoff between soundness and performance</h3>
<p>Lastly, there was a tradeoff where some functions were arbitrarily marked as safe, even though they are unsafe under
same conditions. Whether that tradeoff is justified is up to the programmer.</p>
<h3>Testing</h3>
<p>Some tests were created and run to ensure</p>
<h3>Shortcomings</h3>
<p>There are a few things that should be fixed up to make this module properly safe.</p>
<ol>
<li>~~Make sure that the <code>*file</code> can be turned into an immutable reference, or better yet,
create a <code>Rust</code>-abstraction for it. It itself contains locks, and data that is safe to mutate
behind those locks. For it to safely be an immutable reference, that data must not be changed
while holding the immutable reference, with or without the lock, since the data isn't modeled
to be guarded, from <code>Rust</code>'s point of vue that immutable data changed when we promised not to.
That can't happen from <code>Rust</code>-code because of the immutable reference, but if <code>C</code>-code changes it
that's UB.~~
<li>Make the module-api sound by implementing or using <code>PinInit</code> in such a way that an
<code>static UnsafeCell&#x3C;Option&#x3C;..>></code> can be used instead of a <code>static mut MaybeUninit</code>,
there should be no performance hit if using <code>unwrap_unchecked</code> on the option anyway, it's just
better.
</ol>
</div>
</div>