<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

    <meta charset="UTF-8">
    <base href="/">
    <link rel="stylesheet" href="static/styles.css">
    <link rel="stylesheet" href="static/github-markdown.css">
    <link rel="stylesheet" href="static/starry_night.css">
    <title>X11ToXcb</title>


<div id="menu">
<a href=/ class="menu-item">Home</a><a href=/table-of-contents.html class="menu-item">Table of contents</a>
</div>
<div id="content">
<div class="markdown-body"><h1>Rewrite it in Rust, a cautionary tale</h1>
<p>RIIR (Rewrite It In Rust) is a pretty fun joke, at my current workplace my team writes
essentially everything in Rust, for good and bad. We like to have a bit of
fun with it, pushing the RIIR-agenda around the company.</p>
<p>But, this short retrospective is about when porting something from C-bindings to Rust
just made life harder.</p>
<h2>Security advisory on Rust XCB-bindings</h2>
<p>I've written a lot about <a href="https://en.wikipedia.org/wiki/XCB">XCB</a> and
<a href="https://en.wikipedia.org/wiki/X_Window_System">X11</a> in my project write-ups
about my <a href="https://github.com/MarcusGrass/pgwm">x11-wm</a>, I'm not going
to get into it here, but for these purposes <code>XCB</code> can be summarized as a
library to handle displaying things on a desktop.</p>
<p>One day when building a project, a security advisory comes up on <a href="https://github.com/rust-x-bindings/rust-xcb">Rust's XCB bindings</a>.</p>
<h3>Bindings</h3>
<p>Generally if you want to use an existing big library, you can take the approach of reinventing the wheel,
or creating bindings to a C-library that already exists. For example,
Rust has a <a href="https://crates.io/crates/zstd">zstd crate</a> which contains bindings
to <a href="https://github.com/facebook/zstd">libzstd</a>. If you want to use that,
you need to have <code>libzstd</code> available to the binary. Sometimes, it's built as
part of a build-script and statically compiled into the binary, then you don't
have to worry about it at all (<a href="https://docs.rs/rocksdb/latest/rocksdb/">Rocksdb does this I think</a>).
There's also a pure Rust implementation of <a href="https://github.com/KillingSpark/zstd-rs">zstd decompression</a>,
which is the other approach, same algorithm, different implementation.</p>
<h3>Why not?</h3>
<p>There are some good reasons to RIIR, all the good things about using Rust can go here.
But, there are some very good reasons not to, apart from the effort.<br>
The one this retrospective is about is maturity, and the robustness that can come from it.</p>
<h3>Porting x11-clipboard from C-bindings to Rust implementation</h3>
<p>The security advisory comes up, transitively through <a href="https://github.com/quininer/x11-clipboard">x11-clipboard</a>,
but the advisory is on the <code>XCB</code>-bindings.<br>
As I mentioned, my previous work on my WM had made me familiar with a Rust
library that replaces the bindings: <a href="https://github.com/psychon/x11rb">x11rb</a>.</p>
<p>To be clear, <code>x11rb</code> is a great library, and the story is not about how it contained some unexpected bug,
it didn't, it was the act of replacement that became the issue.</p>
<p><a href="https://github.com/quininer/x11-clipboard/pull/29">I made a PR on June16, 2022</a> to replace usage of the bindings, to
<code>x11rb</code> in `x11-clipboard. The PR is fairly large, but very procedural. The rust-api
is essentially the same as the C-one, it was mostly a matter of changing the types.</p>
<h2>Creeping issues</h2>
<p><code>x11-clipboard</code> is a library that handles copying and pasting withing x11-sessions. It's used for a lot of Rust's
gui-applications, so people are likely to run into mistakes if you make them, and there were mistakes.</p>
<h3>Bug report through alacritty</h3>
<p>9 months later, <a href="https://github.com/alacritty/alacritty/issues/6760">alacritty gets a bug report</a>, where
when things are pasted FROM alacritty into other applications, they hang.</p>
<p>The bug report is floated into <a href="https://github.com/quininer/x11-clipboard/issues/33">x11-clipboards issue tracker</a> after
a bisection shows that the problem comes from the version update caused by my change.</p>
<p>Debugging it was medium-difficult, it was easy to reproduce, but difficult to understand, but in the end it was
resolved by a <a href="https://github.com/quininer/x11-clipboard/pull/34">+1 -1 change</a>,</p>
<p>From this:</p>
<div class="highlight highlight-rust"><pre>        <span class="pl-smi">time</span><span class="pl-k">:</span> <span class="pl-smi">event</span><span class="pl-k">.</span>time,
        <span class="pl-smi">requestor</span><span class="pl-k">:</span> <span class="pl-smi">event</span><span class="pl-k">.</span>requestor,
        <span class="pl-smi">selection</span><span class="pl-k">:</span> <span class="pl-smi">event</span><span class="pl-k">.</span>selection,
        <span class="pl-smi">target</span>,
        <span class="pl-smi">property</span><span class="pl-k">:</span> <span class="pl-smi">event</span><span class="pl-k">.</span>property
    }
);
</pre></div>
<p>To this:</p>
<div class="highlight highlight-rust"><pre>        <span class="pl-smi">time</span><span class="pl-k">:</span> <span class="pl-smi">event</span><span class="pl-k">.</span>time,
        <span class="pl-smi">requestor</span><span class="pl-k">:</span> <span class="pl-smi">event</span><span class="pl-k">.</span>requestor,
        <span class="pl-smi">selection</span><span class="pl-k">:</span> <span class="pl-smi">event</span><span class="pl-k">.</span>selection,
        <span class="pl-smi">target</span><span class="pl-k">:</span> <span class="pl-smi">event</span><span class="pl-k">.</span>target,
        <span class="pl-smi">property</span><span class="pl-k">:</span> <span class="pl-smi">event</span><span class="pl-k">.</span>property
    }
);
</pre></div>
<p>The error was interesting, it caused some clients (a client in this context is an application like
<a href="https://brave.com/">Brave browser</a>) to hang waiting for a notification that the application never sent.</p>
<p>A funny note about <code>X11</code> is that the protocol has been around for so long, and seen so much misuse, that a lot of
clients are built to handle this kind of mistake, so the error doesn't show up on for example
<a href="https://www.mozilla.org/en-US/firefox/new/">Firefox</a>.</p>
<h3>Bug report through pot-app</h3>
<p><a href="https://github.com/pot-app/Selection/issues/3">On Jan 17, 2024 a bug report comes in from pot-app/Selection</a>.</p>
<p><a href="https://github.com/pot-app">Pot App is:</a></p>
<blockquote>
<p>üåà‰∏Ä‰∏™Ë∑®Âπ≥Âè∞ÁöÑÂàíËØçÁøªËØëÂíåOCRËΩØ‰ª∂ | A cross-platform software for text translation and recognition.</p>
</blockquote>
<p>To be fair, I think this was a pre-existing bug, but I was kind of on the hook at this point, and it was interesting.</p>
<p>The clipboard library spawns a thread that listens for events, this threads holds a claim to the connection to the
x-server, blocking waiting for a reply. Even if the handle that's given to the user is dropped that thread stays alive, keeping
the connection alive. This means that if you're recreating the structure in a loop for example, you start leaking
connections until the connection-pool is drained, which means that no new clients can connect. Or in other words,
no more applications can start because you clogged up the server.</p>
<p>A problem here is that the thread needs to know from the structure that spawned it, that it's done and should quit.
There are not many nice way of signalling threads like that they are blocked waiting for something.</p>
<p>The thread waits like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">while</span> <span class="pl-k">let</span> <span class="pl-en">Ok</span>(<span class="pl-smi">event</span>) <span class="pl-k">=</span> <span class="pl-smi">context</span><span class="pl-k">.</span>connection<span class="pl-k">.</span><span class="pl-en">wait_for_event</span>() {
</pre></div>
<p>The API doesn't have other facilities for waiting other than polling in a loop, and ideally one doesn't want to
run the thread at 100% CPU just waiting.</p>
<p>However, you can get the underlying file descriptor for the connection like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">let</span> <span class="pl-smi">stream_fd</span> <span class="pl-k">=</span> <span class="pl-smi">context</span><span class="pl-k">.</span>connection<span class="pl-k">.</span><span class="pl-en">stream</span>()<span class="pl-k">.</span><span class="pl-en">as_fd</span>();
</pre></div>
<p>And if you have an FD, you can use Linux's APIs to check for readiness, instead of what's exposed through the
<code>x11rb</code> API. This is only running on Linux anyway, so why not? (This is foreshadowing).</p>
<p>In the end <a href="https://github.com/quininer/x11-clipboard/pull/46">I make a PR</a> that uses <a href="https://github.com/rust-lang/libc">libc</a>,
the <a href="https://man7.org/linux/man-pages/man2/poll.2.html">Linux Poll API</a>, and an,
<a href="https://man7.org/linux/man-pages/man2/eventfd.2.html">eventfd</a>.
If the struct is dropped, it'll write an event on the <code>eventfd</code>. On the other side, the thread polls for
either a new message on the stream, or an event on the <code>eventfd</code>, if an event arrives on the stream, it'll handle that
like before, if it arrives through the <code>eventfd</code> it just quits.  That solved the issue.</p>
<h3>Bug report through the regular issue tracker</h3>
<p><a href="https://github.com/quininer/x11-clipboard/issues/48">On Feb 28, 2024 a bug report is posted on x11-clipboard</a>.</p>
<p>Now, I figured <code>X11</code> was only used on Linux, Mac and Windows have their own display systems. But, I forgot about
the BSDs, those operation systems can run <code>X11</code>, and I should have thought about that before picking the
Linux specific <code>eventfd</code>.</p>
<h4>POSIX</h4>
<p><a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> is an OS-compatibility standard, if you use POSIX-compliant OS-apis,
can generally get away with using APIs that interface with the OS for Linux and they'll still work for the BSDs,
some examples: <code>poll</code>, <a href="https://man7.org/linux/man-pages/man2/read.2.html">read</a>, <a href="https://man7.org/linux/man-pages/man2/write.2.html">write</a>,
<a href="https://man7.org/linux/man-pages/man2/pipe.2.html">pipe</a>. <code>eventfd</code> is a counter-example.</p>
<p>What my bugfix was trying to achieve was a drop of the struct exposed through the <code>x11-clipboard</code> API causing something
pollable to happen in the running thread. I thought <code>eventfd</code> was a good fit, but something POSIX-compliant would be
to create a <code>pipe</code>, two fds, a read-end and a write-end, put the write-end in the user struct, the read-end in the
thread, and poll for a <code>POLLHUP</code> (hangup), that gets sent to one end when the other end's <code>FD</code> is closed.</p>
<p>Now I could use the existing RAII-closing of the write-end on the user struct, and just listen to a hangup on the running
thread, and it works on the BSDs!</p>
<h2>Conclusion</h2>
<p>For now that's been it, I'll update this if more stuff comes in. I think that lessons learned here are that there's a
maintenance cost to any change. While RIIR might be fun, it's good to think twice about how reasonable it is.</p>
<p>Of course, there may be lurking bugs in the C-implementation that isn't seen because of selection bias, but I don't have
any basis for that.</p>
<p>Last of all, I'm sorry for the hassle <a href="https://github.com/quininer">quininer</a>, I know you don't want to maintain this
project anymore, and I made your life a bit more difficult.</p>
</div>
</div>