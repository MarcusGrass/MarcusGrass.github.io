<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/html">

    <meta charset="UTF-8">
    <base href="/">
    <link rel="stylesheet" href="static/styles.css">
    <link rel="stylesheet" href="static/github-markdown.css">
    <link rel="stylesheet" href="static/starry_night.css">
    <title>StaticPie</title>


<div id="menu">
<a href=/ class="menu-item">Home</a><a href=/table-of-contents.html class="menu-item">Table of contents</a>
</div>
<div id="content">
<div class="markdown-body"><h1>Static pie linking a nolibc Rust binary</h1>
<p>Something has been bugging me for a while with <a href="https://github.com/MarcusGrass/tiny-std">tiny-std</a>,
if I try to compile executables created with them as <code>-C target-feature=+crt-static</code> (statically link the <code>C</code>-runtime),
it segfaults.</p>
<p>The purpose of creating <code>tiny-std</code> was to avoid <code>C</code>, but to get <code>Rust</code> to link a binary statically, that flag needs
to be passed. <code>-C target-feature=+crt-static -C relocation-model=static</code> does produce a valid binary though.
The default relocation-model for static binaries is <code>-C relocation-model=pie</code>,
(at least for the target <code>x86_64-unknown-linux-gnu</code>) so something about <code>PIE</code>-executables created with <code>tiny-std</code> fails,
in this writeup I'll go into the solution for that.</p>
<h2>Static pie linking</h2>
<p>Static pie linking is a combination of two concepts.</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Static_library">Static linking</a>, putting everything in the same place at compile time.
As opposed to dynamic linking, where library dependencies can be found and used at runtime.
Statically linking an executable gives it the property that it can be run on any system
that can handle the executable type, i.e. I can start a statically linked elf-executable on any platform that can run
elf-executables. Whereas a dynamically linked executable will not start if its dynamic dependencies cannot be found
at application start.
<li><a href="https://en.wikipedia.org/wiki/Position-independent_code">Position-independent code</a> is able to run properly
regardless of where in memory is placed. The benefit, as I understand it, is security, and platform compatibility-related.
</ol>
<p>When telling <code>rustc</code> to create a static-pie linked executable through <code>-C target-feature=+crt-static -C relocation-model=pie</code>
(relocation-model defaults to pie, could be omitted), it creates an elf-executable which has a header that marks it as
<code>DYN</code>. Here's what an example <code>readelf -h</code> looks like:</p>
<div class="highlight highlight-shell"><pre>ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2<span class="pl-s"><span class="pl-pds">'</span>s complement, little endian</span>
<span class="pl-s">  Version:                           1 (current)</span>
<span class="pl-s">  OS/ABI:                            UNIX - System V</span>
<span class="pl-s">  ABI Version:                       0</span>
<span class="pl-s">  Type:                              DYN (Position-Independent Executable file)</span>
<span class="pl-s">  Machine:                           Advanced Micro Devices X86-64</span>
<span class="pl-s">  Version:                           0x1</span>
<span class="pl-s">  Entry point address:               0x24b8</span>
<span class="pl-s">  Start of program headers:          64 (bytes into file)</span>
<span class="pl-s">  Start of section headers:          1894224 (bytes into file)</span>
<span class="pl-s">  Flags:                             0x0</span>
<span class="pl-s">  Size of this header:               64 (bytes)</span>
<span class="pl-s">  Size of program headers:           56 (bytes)</span>
<span class="pl-s">  Number of program headers:         9</span>
<span class="pl-s">  Size of section headers:           64 (bytes)</span>
<span class="pl-s">  Number of section headers:         32</span>
<span class="pl-s">  Section header string table index: 20</span>
</pre></div>
<p>This signals to the OS that the executable can be run position-independently, but since <code>tiny-std</code> assumes that
memory addresses are absolute, the ones they were when compiled, the executable segfaults as soon as it tries to get
the address of any symbols, like functions or static variables, since those have been moved.</p>
<h2>Where are my symbols?</h2>
<p>This seems like a tricky problem, as a programmer, I have a bunch of variable and function calls, some that the
<code>Rust</code>-language emits for me, now each of the addresses for those variables and functions are in another place in memory.<br>
Before using any of them I need to remap them, which means that I need to have remapping code before using any
function calls (kinda).</p>
<h2>The start function</h2>
<p>The executable enters through the <code>_start</code> function, this is defined in <code>asm</code> for <code>tiny-std</code>:</p>
<div class="highlight highlight-rust"><pre><span class="pl-c">// Binary entrypoint</span>
#[cfg(all(feature <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>symbols<span class="pl-pds">"</span></span>, feature <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>start<span class="pl-pds">"</span></span>, target_arch <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>x86_64<span class="pl-pds">"</span></span>))]
<span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">arch</span><span class="pl-k">::</span><span class="pl-en">global_asm!</span>(
    <span class="pl-s"><span class="pl-pds">"</span>.text<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>.global _start<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>.type _start,@function<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>_start:<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>xor rbp,rbp<span class="pl-pds">"</span></span>,<span class="pl-c"> // Zero the stack-frame pointer</span>
    <span class="pl-s"><span class="pl-pds">"</span>mov rdi, rsp<span class="pl-pds">"</span></span>,<span class="pl-c"> // Move the stack pointer into rdi, c-calling convention arg 1</span>
    <span class="pl-s"><span class="pl-pds">"</span>.weak _DYNAMIC<span class="pl-pds">"</span></span>,<span class="pl-c"> // Elf dynamic symbol</span>
    <span class="pl-s"><span class="pl-pds">"</span>.hidden _DYNAMIC<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>lea rsi, [rip + _DYNAMIC]<span class="pl-pds">"</span></span>,<span class="pl-c"> // Load the dynamic address off the next instruction to execute incremented by _DYNAMIC into rsi</span>
    <span class="pl-s"><span class="pl-pds">"</span>and rsp,-16<span class="pl-pds">"</span></span>,<span class="pl-c"> // Align the stack pointer</span>
    <span class="pl-s"><span class="pl-pds">"</span>call __proxy_main<span class="pl-pds">"</span></span><span class="pl-c"> // Call our rust start function</span>
);
</pre></div>
<p>The assembly prepares the stack by aligning it, putting the stack pointer into arg1 for the coming function-call,
then adds the offset off <code>_DYNAMIC</code> to the special purpose <code>rip</code>-register address, and puts that in <code>rsi</code> which becomes
our called function's arg 2.</p>
<p>After that <code>__proxy_main</code> is called, the signature looks like this:</p>
<p><code>unsafe extern "C" fn __proxy_main(stack_ptr: *const u8, dynv: *const usize)</code>
It takes the <code>stack_ptr</code> and the <code>dynv</code>-dynamic vector as arguments, which were provided in
the above assembly.</p>
<p>I wrote more about the <code>_start</code>-function in <a href="/pgwm03">pgwm03</a> and <a href="https://fasterthanli.me/series/making-our-own-executable-packer/part-12">fasterthanli.me</a>
wrote more about it at their great blog, but in short:</p>
<p>Before running the user's <code>main</code> some setup is required, like arguments, environment variables, <a href="https://man7.org/linux/man-pages/man3/getauxval.3.html">aux-values</a>,
map in faster functions from the vdso (see <a href="/pgwm03">pgwm03</a> for more on that), and set up some thread-state,
see <a href="/threads">the thread writeup</a> for that.</p>
<p>All these variables come off the executable's stack, which is why stack pointer needs to be passed as an argument to
our setup-function, so that it can be used before the stack is polluted by the setup function.</p>
<p>The first extraction looks like this:</p>
<div class="highlight highlight-rust"><pre>#[no_mangle]
#[cfg(all(feature <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>symbols<span class="pl-pds">"</span></span>, feature <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>start<span class="pl-pds">"</span></span>))]
<span class="pl-k">unsafe</span> <span class="pl-k">extern</span> <span class="pl-s"><span class="pl-pds">"</span>C<span class="pl-pds">"</span></span> <span class="pl-k">fn</span> <span class="pl-en">__proxy_main</span>(<span class="pl-smi">stack_ptr</span><span class="pl-k">:</span> <span class="pl-k">*const</span> <span class="pl-en">u8</span>, <span class="pl-smi">dynv</span><span class="pl-k">:</span> <span class="pl-k">*const</span> <span class="pl-en">usize</span>) {
<span class="pl-c">    // Fist 8 bytes is a u64 with the number of arguments</span>
    <span class="pl-k">let</span> <span class="pl-smi">argc</span> <span class="pl-k">=</span> <span class="pl-k">*</span>(<span class="pl-smi">stack_ptr</span> <span class="pl-k">as</span> <span class="pl-k">*const</span> <span class="pl-en">u64</span>);
<span class="pl-c">    // Directly followed by those arguments, bump pointer by 8 bytes</span>
    <span class="pl-k">let</span> <span class="pl-smi">argv</span> <span class="pl-k">=</span> <span class="pl-smi">stack_ptr</span><span class="pl-k">.</span><span class="pl-en">add</span>(<span class="pl-c1">8</span>) <span class="pl-k">as</span> <span class="pl-k">*const</span> <span class="pl-k">*const</span> <span class="pl-en">u8</span>;
    <span class="pl-k">let</span> <span class="pl-smi">ptr_size</span> <span class="pl-k">=</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">mem</span><span class="pl-k">::</span><span class="pl-en">size_of</span><span class="pl-k">::</span>&#x3C;<span class="pl-en">usize</span>>();
<span class="pl-c">    // Directly followed by a pointer to the environment variables, it's just a null terminated string.</span>
<span class="pl-c">    // This isn't specified in Posix and is not great for portability, but this isn't meant to be portable outside of Linux.</span>
    <span class="pl-k">let</span> <span class="pl-smi">env_offset</span> <span class="pl-k">=</span> <span class="pl-c1">8</span> <span class="pl-k">+</span> <span class="pl-smi">argc</span> <span class="pl-k">as</span> <span class="pl-en">usize</span> <span class="pl-k">*</span> <span class="pl-smi">ptr_size</span> <span class="pl-k">+</span> <span class="pl-smi">ptr_size</span>;
<span class="pl-c">    // Bump pointer by combined offset</span>
    <span class="pl-k">let</span> <span class="pl-smi">envp</span> <span class="pl-k">=</span> <span class="pl-smi">stack_ptr</span><span class="pl-k">.</span><span class="pl-en">add</span>(<span class="pl-smi">env_offset</span>) <span class="pl-k">as</span> <span class="pl-k">*const</span> <span class="pl-k">*const</span> <span class="pl-en">u8</span>;
    <span class="pl-k">let</span> <span class="pl-k">mut</span> <span class="pl-smi">null_offset</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">loop</span> {
        <span class="pl-k">let</span> <span class="pl-smi">val</span> <span class="pl-k">=</span> <span class="pl-k">*</span>(<span class="pl-smi">envp</span><span class="pl-k">.</span><span class="pl-en">add</span>(<span class="pl-smi">null_offset</span>));
        <span class="pl-k">if</span> <span class="pl-smi">val</span> <span class="pl-k">as</span> <span class="pl-en">usize</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> {
            <span class="pl-k">break</span>;
        }
        <span class="pl-smi">null_offset</span> <span class="pl-k">+=</span> <span class="pl-c1">1</span>;
    }
<span class="pl-c">    // We now know how long the envp is</span>
<span class="pl-c">    // ... </span>
}
</pre></div>
<p>This works all the same as a <code>pie</code> because:</p>
<h2>Prelude, inline</h2>
<p>There will be trouble when trying to find a symbol contained in the binary, such as a function call.<br>
Up to here, that hasn't been a problem because even though <code>ptr::add()</code> and <code>core::mem:size_of::&#x3C;T>()</code> is invoked,
no addresses are needed for those. This is because of inlining.</p>
<p>Looking at <code>core::mem::size_of&#x3C;T>()</code>:</p>
<div class="highlight highlight-rust"><pre>#[inline(always)]
#[must_use]
#[stable(feature <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>rust1<span class="pl-pds">"</span></span>, since <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>1.0.0<span class="pl-pds">"</span></span>)]
#[rustc_promotable]
#[rustc_const_stable(feature <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>const_mem_size_of<span class="pl-pds">"</span></span>, since <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>1.24.0<span class="pl-pds">"</span></span>)]
#[cfg_attr(not(test), rustc_diagnostic_item <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>mem_size_of<span class="pl-pds">"</span></span>)]
<span class="pl-k">pub</span> <span class="pl-k">const</span> <span class="pl-k">fn</span> <span class="pl-en">size_of</span>&#x3C;<span class="pl-en">T</span>>() <span class="pl-k">-></span> <span class="pl-en">usize</span> {
    <span class="pl-en">intrinsics</span><span class="pl-k">::</span><span class="pl-en">size_of</span><span class="pl-k">::</span>&#x3C;<span class="pl-en">T</span>>()
}
</pre></div>
<p>It has the <code>#[inline(always)]</code> attribute, the same goes for <code>ptr::add()</code>. Since that code is inlined,
an address to a function isn't necessary, and therefore it works even though all of the addresses are off.</p>
<p>To be able to debug, I would like to be able to print variables, since I haven't been able to hook a debugger up
to <code>tiny-std</code> executables yet. But, printing to the terminal requires code, code that usually isn't <code>#[inline(always)]</code>.</p>
<p>So I wrote a small print:</p>
<div class="highlight highlight-rust"><pre>#[inline(always)]
<span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">print_labeled</span>(<span class="pl-smi">msg</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span>[<span class="pl-en">u8</span>], <span class="pl-smi">val</span><span class="pl-k">:</span> <span class="pl-en">usize</span>) {
    <span class="pl-en">print_label</span>(<span class="pl-smi">msg</span>);
    <span class="pl-en">print_val</span>(<span class="pl-smi">val</span>);
}
#[inline(always)]
<span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">print_label</span>(<span class="pl-smi">msg</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span>[<span class="pl-en">u8</span>]) {
    <span class="pl-en">syscall!</span>(<span class="pl-c1">WRITE</span>, <span class="pl-c1">1</span>, <span class="pl-smi">msg</span><span class="pl-k">.</span><span class="pl-en">as_ptr</span>(), <span class="pl-smi">msg</span><span class="pl-k">.</span><span class="pl-en">len</span>());
}
#[inline(always)]
<span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">print_val</span>(<span class="pl-smi">u</span><span class="pl-k">:</span> <span class="pl-en">usize</span>) {
    <span class="pl-en">syscall!</span>(<span class="pl-c1">WRITE</span>, <span class="pl-c1">1</span>, <span class="pl-en">num_to_digits</span>(<span class="pl-smi">u</span>)<span class="pl-k">.</span><span class="pl-en">as_ptr</span>(), <span class="pl-c1">21</span>);
}
#[inline(always)]
<span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">num_to_digits</span>(<span class="pl-k">mut</span> <span class="pl-smi">u</span><span class="pl-k">:</span> <span class="pl-en">usize</span>) <span class="pl-k">-></span> [<span class="pl-en">u8</span>; <span class="pl-c1">22</span>] {
    <span class="pl-k">let</span> <span class="pl-k">mut</span> <span class="pl-smi">base</span> <span class="pl-k">=</span> <span class="pl-k">*</span><span class="pl-s">b<span class="pl-pds">"</span><span class="pl-cce">\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n</span><span class="pl-pds">"</span></span>;
    <span class="pl-k">let</span> <span class="pl-k">mut</span> <span class="pl-smi">ind</span> <span class="pl-k">=</span> <span class="pl-smi">base</span><span class="pl-k">.</span><span class="pl-en">len</span>() <span class="pl-k">-</span> <span class="pl-c1">2</span>;
    <span class="pl-k">if</span> <span class="pl-smi">u</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> {
        <span class="pl-smi">base</span>[<span class="pl-smi">ind</span>] <span class="pl-k">=</span> <span class="pl-c1">48</span>;
    }
    <span class="pl-k">while</span> <span class="pl-smi">u</span> <span class="pl-k">></span> <span class="pl-c1">0</span> {
        <span class="pl-k">let</span> <span class="pl-smi">md</span> <span class="pl-k">=</span> <span class="pl-smi">u</span> <span class="pl-k">%</span> <span class="pl-c1">10</span>;
        <span class="pl-smi">base</span>[<span class="pl-smi">ind</span>] <span class="pl-k">=</span> <span class="pl-smi">md</span> <span class="pl-k">as</span> <span class="pl-en">u8</span> <span class="pl-k">+</span> <span class="pl-c1">48</span>;
        <span class="pl-smi">ind</span> <span class="pl-k">-=</span> <span class="pl-c1">1</span>;
        <span class="pl-smi">u</span> <span class="pl-k">=</span> <span class="pl-smi">u</span> <span class="pl-k">/</span> <span class="pl-c1">10</span>;
    }
    <span class="pl-smi">base</span>
}
</pre></div>
<p>Printing to the terminal can be done through the syscall <code>WRITE</code> on <code>fd</code> <code>1</code> (<code>STDOUT</code>).<br>
It takes a buffer of bytes and a length. The call through <code>syscall!()</code> is always inlined.</p>
<p>Since I primarily need look at addresses, I just print <code>usize</code>, and I wrote a beautifully stupid number to digits function.<br>
Since the max digits of a <code>usize</code> on a 64-bit machine is 21, I allocate a slice on the stack filled with
<code>null</code>-bytes, these won't be displayed. Then add digit by digit, which means that the number is formatted without leading or
trailing zeroes.</p>
<p>Invoking it looks like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">fn</span> <span class="pl-en">test</span>() {
    <span class="pl-en">print_labeled</span>(<span class="pl-s">b<span class="pl-pds">"</span>My msg as bytes: <span class="pl-pds">"</span></span>, <span class="pl-c1">15</span>);
}
</pre></div>
<h2>Relocation</h2>
<p>Now that basic debug-printing is possible work to relocate the addresses can begin.</p>
<p>I previously had written some code the extract <code>aux</code>-values, but now that code needs to run without using any
non-inlined functions or variables.</p>
<h3>Aux values</h3>
<p>A good description of aux-values comes from <a href="https://man7.org/linux/man-pages/man3/getauxval.3.html">the docs here</a>,
in short the kernel puts some data in the memory of a program when it's loaded.<br>
This data points to other data that is needed to do relocation. It also has an insane layout for reasons that
I haven't yet been able to find any motivation for.<br>
A pointer to the aux-values are put after the <code>envp</code> on the stack.</p>
<p>The aux-values were collected and stored pretty sloppily as a global static variable before implementing this change,
this time it needs to be collected onto the stack, used for finding the dynamic relocation addresses,
and then it could be put into a static variable after that (since the address of the static variable can't be found before
remapping).</p>
<p>The <code>dyn</code>-values are also required, which are essentially the same as aux-values, provided for <code>DYN</code>-objects.</p>
<p>In musl, the aux-values that are put on the stack looks like this:</p>
<div class="highlight highlight-c"><pre><span class="pl-c1">size_t</span> i, aux[AUX_CNT], dyn[DYN_CNT];
</pre></div>
<p>So I replicated the aux-vec on the stack like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-c">// There are 32 aux values.</span>
<span class="pl-k">let</span> <span class="pl-k">mut</span> <span class="pl-smi">aux</span><span class="pl-k">:</span> [<span class="pl-c1">0</span><span class="pl-en">usize</span>; <span class="pl-c1">32</span>];
</pre></div>
<p>And then initialize it, with the <code>aux</code>-pointer provided by the OS.</p>
<p>The OS-supplies some values in the <code>aux</code>-vector <a href="https://man7.org/linux/man-pages/man3/getauxval.3.html">more info here</a>
the necessary ones for remapping are:</p>
<ol>
<li><code>AT_BASE</code> the base address of the program interpreter, 0 if no interpreter (static-pie).
<li><code>AT_PHNUM</code>, the number of program headers.
<li><code>AT_PHENT</code>, the size of one program header entry.
<li><code>AT_PHDR</code>, the address of the program headers in the executable.
</ol>
<p>First a virtual address found at the program header that has the <code>dynamic</code> type must be found.</p>
<p>The program header is laid out in memory as this struct:</p>
<div class="highlight highlight-rust"><pre>#[repr(<span class="pl-en">C</span>)]
#[derive(<span class="pl-en">Debug</span>, <span class="pl-en">Copy</span>, <span class="pl-en">Clone</span>)]
<span class="pl-k">pub</span> <span class="pl-k">struct</span> <span class="pl-smi">elf64_phdr</span> {
    <span class="pl-k">pub</span> <span class="pl-smi">p_type</span><span class="pl-k">:</span> Elf64_Word,
    <span class="pl-k">pub</span> <span class="pl-smi">p_flags</span><span class="pl-k">:</span> Elf64_Word,
    <span class="pl-k">pub</span> <span class="pl-smi">p_offset</span><span class="pl-k">:</span> Elf64_Off,
    <span class="pl-k">pub</span> <span class="pl-smi">p_vaddr</span><span class="pl-k">:</span> Elf64_Addr,
    <span class="pl-k">pub</span> <span class="pl-smi">p_paddr</span><span class="pl-k">:</span> Elf64_Addr,
    <span class="pl-k">pub</span> <span class="pl-smi">p_filesz</span><span class="pl-k">:</span> Elf64_Xword,
    <span class="pl-k">pub</span> <span class="pl-smi">p_memsz</span><span class="pl-k">:</span> Elf64_Xword,
    <span class="pl-k">pub</span> <span class="pl-smi">p_align</span><span class="pl-k">:</span> Elf64_Xword,
}
</pre></div>
<p>The address of the <code>AT_PHDR</code> can be treated as an array declared as:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">let</span> <span class="pl-smi">phdr</span><span class="pl-k">:</span> <span class="pl-k">&#x26;</span>[<span class="pl-smi">elf64_phdr</span>; <span class="pl-c1">AT_PHNUM</span>] <span class="pl-k">=</span> <span class="pl-k">...</span>
</pre></div>
<p>That array can be walked until finding a program header struct with <code>p_type</code> = <code>PT_DYNAMIC</code>,
that program header holds an offset at <code>p_vaddr</code> that can be subtracted from the <code>dynv</code> pointer to get
the correct <code>base</code> address.</p>
<h2>Initialize the dyn section</h2>
<p>The <code>dynv</code> pointer supplied by the os, as previously stated, is analogous to the <code>aux</code>-pointer but
trying to stack allocate its value mappings like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">let</span> <span class="pl-smi">dyn_values</span> <span class="pl-k">=</span> [<span class="pl-c1">0</span><span class="pl-en">usize</span>; <span class="pl-c1">37</span>];
</pre></div>
<p>Will cause a segfault.</p>
<h3>SYMBOLS!!!</h3>
<p>It took me a while to figure out what's happening, a zeroed array is allocated in rust, and
that array is larger than <code>[0usize; 32]</code> (256 bytes of zeroes seems to be the exact breakpoint)
<code>rustc</code> instead of using <code>sse</code> instructions, uses <code>memset</code> to zero the memory it just took off the stack.</p>
<p>The asm will look like this:</p>
<pre><code class="language-asm">        ...
        mov edx, 296
        mov rdi, rbx
        xor esi, esi
        call qword ptr [rip + memset@GOTPCREL]
        ...
</code></pre>
<p>Accessing that memset symbol is what causes the segfault.<br>
I tried a myriad of ways to get the compiler to not emit that symbol, among
<a href="https://users.rust-lang.org/t/reliably-working-around-rust-emitting-memset-when-putting-a-slice-on-the-stack/97080">posting this</a>
help request.</p>
<p>It seems that there is no reliable way to avoid <code>rustc</code> emitting unwanted symbols without doing it all in assembly,
and since that seems a bit much, at least right now, I opted to instead restructure the code. Unpacking both
the aux and dyn values and just keeping what <code>tiny-std</code> needs.<br>
The unpacked aux values now look like this:</p>
<div class="highlight highlight-rust"><pre><span class="pl-c">/// Some selected aux-values, needs to be kept small since they're collected</span>
<span class="pl-c">/// before symbol relocation on static-pie-linked binaries, which means rustc</span>
<span class="pl-c">/// will emit memset on a zeroed allocation of over 256 bytes, which we won't be able</span>
<span class="pl-c">/// to find and thus will result in an immediate segfault on start.</span>
<span class="pl-c">/// See [docs](https://man7.org/linux/man-pages/man3/getauxval.3.html)</span>
#[derive(<span class="pl-en">Debug</span>)]
<span class="pl-k">pub</span>(<span class="pl-k">crate</span>) <span class="pl-k">struct</span> <span class="pl-en">AuxValues</span> {
<span class="pl-c">    /// Base address of the program interpreter</span>
    <span class="pl-k">pub</span>(<span class="pl-k">crate</span>) <span class="pl-smi">at_base</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
<span class="pl-c">    /// Real group id of the main thread</span>
    <span class="pl-k">pub</span>(<span class="pl-k">crate</span>) <span class="pl-smi">at_gid</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
<span class="pl-c">    /// Real user id of the main thread</span>
    <span class="pl-k">pub</span>(<span class="pl-k">crate</span>) <span class="pl-smi">at_uid</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
<span class="pl-c">    /// Address of the executable's program headers</span>
    <span class="pl-k">pub</span>(<span class="pl-k">crate</span>) <span class="pl-smi">at_phdr</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
<span class="pl-c">    /// Size of program header entry</span>
    <span class="pl-k">pub</span>(<span class="pl-k">crate</span>) <span class="pl-smi">at_phent</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
<span class="pl-c">    /// Number of program headers</span>
    <span class="pl-k">pub</span>(<span class="pl-k">crate</span>) <span class="pl-smi">at_phnum</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
<span class="pl-c">    /// Address pointing to 16 bytes of a random value</span>
    <span class="pl-k">pub</span>(<span class="pl-k">crate</span>) <span class="pl-smi">at_random</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
<span class="pl-c">    /// Executable should be treated securely</span>
    <span class="pl-k">pub</span>(<span class="pl-k">crate</span>) <span class="pl-smi">at_secure</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
<span class="pl-c">    /// Address of the vdso</span>
    <span class="pl-k">pub</span>(<span class="pl-k">crate</span>) <span class="pl-smi">at_sysinfo_ehdr</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
}
</pre></div>
<p>It only contains the aux-values that are actually used by <code>tiny-std</code>.</p>
<p>The dyn-values are only used for relocations so far, so they were packed into this much smaller struct:</p>
<div class="highlight highlight-rust"><pre><span class="pl-k">pub</span>(<span class="pl-k">crate</span>) <span class="pl-k">struct</span> <span class="pl-en">DynSection</span> {
    <span class="pl-smi">rel</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
    <span class="pl-smi">rel_sz</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
    <span class="pl-smi">rela</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
    <span class="pl-smi">rela_sz</span><span class="pl-k">:</span> <span class="pl-en">usize</span>,
}
</pre></div>
<p>Now that <code>rustc</code>'s memset emissions has been sidestepped, the <code>DynSection</code> struct can be filled with the values from the
<code>dynv</code>-pointer, and then finally the symbols can be relocated:</p>
<div class="highlight highlight-rust"><pre>#[inline(always)]
<span class="pl-k">pub</span>(<span class="pl-k">crate</span>) <span class="pl-k">unsafe</span> <span class="pl-k">fn</span> <span class="pl-en">relocate</span>(<span class="pl-k">&#x26;</span><span class="pl-c1">self</span>, <span class="pl-smi">base_addr</span><span class="pl-k">:</span> <span class="pl-en">usize</span>) {
<span class="pl-c">    // Relocate all rel-entries</span>
    <span class="pl-k">for</span> <span class="pl-smi">i</span> <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">..</span>(<span class="pl-c1">self</span><span class="pl-k">.</span>rel_sz <span class="pl-k">/</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">mem</span><span class="pl-k">::</span><span class="pl-en">size_of</span><span class="pl-k">::</span>&#x3C;<span class="pl-en">Elf64Rel</span>>()) {
        <span class="pl-k">let</span> <span class="pl-smi">rel_ptr</span> <span class="pl-k">=</span> ((<span class="pl-smi">base_addr</span> <span class="pl-k">+</span> <span class="pl-c1">self</span><span class="pl-k">.</span>rel) <span class="pl-k">as</span> <span class="pl-k">*const</span> <span class="pl-c1">Elf64Rel</span>)<span class="pl-k">.</span><span class="pl-en">add</span>(<span class="pl-smi">i</span>);
        <span class="pl-k">let</span> <span class="pl-smi">rel</span> <span class="pl-k">=</span> <span class="pl-en">ptr_unsafe_ref</span>(<span class="pl-smi">rel_ptr</span>);
        <span class="pl-k">if</span> <span class="pl-smi">rel</span><span class="pl-k">.</span><span class="pl-c1">0.</span>r_info <span class="pl-k">==</span> <span class="pl-en">relative_type</span>(<span class="pl-c1">REL_RELATIVE</span>) {
            <span class="pl-k">let</span> <span class="pl-smi">rel_addr</span> <span class="pl-k">=</span> (<span class="pl-smi">base_addr</span> <span class="pl-k">+</span> <span class="pl-smi">rel</span><span class="pl-k">.</span><span class="pl-c1">0.</span>r_offset <span class="pl-k">as</span> <span class="pl-en">usize</span>) <span class="pl-k">as</span> <span class="pl-k">*mut</span> <span class="pl-en">usize</span>;
            <span class="pl-k">*</span><span class="pl-smi">rel_addr</span> <span class="pl-k">+=</span> <span class="pl-smi">base_addr</span>;
        }
    }
<span class="pl-c">    // Relocate all rela-entries</span>
    <span class="pl-k">for</span> <span class="pl-smi">i</span> <span class="pl-k">in</span> <span class="pl-c1">0</span><span class="pl-k">..</span>(<span class="pl-c1">self</span><span class="pl-k">.</span>rela_sz <span class="pl-k">/</span> <span class="pl-en">core</span><span class="pl-k">::</span><span class="pl-en">mem</span><span class="pl-k">::</span><span class="pl-en">size_of</span><span class="pl-k">::</span>&#x3C;<span class="pl-en">Elf64Rela</span>>()) {
        <span class="pl-k">let</span> <span class="pl-smi">rela_ptr</span> <span class="pl-k">=</span> ((<span class="pl-smi">base_addr</span> <span class="pl-k">+</span> <span class="pl-c1">self</span><span class="pl-k">.</span>rela) <span class="pl-k">as</span> <span class="pl-k">*const</span> <span class="pl-c1">Elf64Rela</span>)<span class="pl-k">.</span><span class="pl-en">add</span>(<span class="pl-smi">i</span>);
        <span class="pl-k">let</span> <span class="pl-smi">rela</span> <span class="pl-k">=</span> <span class="pl-en">ptr_unsafe_ref</span>(<span class="pl-smi">rela_ptr</span>);
        <span class="pl-k">if</span> <span class="pl-smi">rela</span><span class="pl-k">.</span><span class="pl-c1">0.</span>r_info <span class="pl-k">==</span> <span class="pl-en">relative_type</span>(<span class="pl-c1">REL_RELATIVE</span>) {
            <span class="pl-k">let</span> <span class="pl-smi">rel_addr</span> <span class="pl-k">=</span> (<span class="pl-smi">base_addr</span> <span class="pl-k">+</span> <span class="pl-smi">rela</span><span class="pl-k">.</span><span class="pl-c1">0.</span>r_offset <span class="pl-k">as</span> <span class="pl-en">usize</span>) <span class="pl-k">as</span> <span class="pl-k">*mut</span> <span class="pl-en">usize</span>;
            <span class="pl-k">*</span><span class="pl-smi">rel_addr</span> <span class="pl-k">=</span> <span class="pl-smi">base_addr</span> <span class="pl-k">+</span> <span class="pl-smi">rela</span><span class="pl-k">.</span><span class="pl-c1">0.</span>r_addend <span class="pl-k">as</span> <span class="pl-en">usize</span>;
        }
    }
<span class="pl-c">    // Skip implementing relr-entries for now</span>
}
</pre></div>
<p>After the <code>relocate</code>-section runs, <code>symbols</code> can again be used, and <code>tiny-std</code> can continue with the setup.</p>
<h2>Outro</h2>
<p>The commit that added the functionality can be found <a href="https://github.com/MarcusGrass/tiny-std/commit/fce20899b891cb07913800dc63fae991f758a819">here</a>.</p>
<p>Thanks for reading!</p>
</div>
</div>